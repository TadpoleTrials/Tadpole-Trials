<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Tadpole Trials - 1st Rank Biology</title>
  <link rel="icon" href="https://svkhhnulgictmdvqvwte.supabase.co/storage/v1/object/public/favicon//favicon.png" type="image/png">
  <meta name="description" content="Jump into Tadpole Trials ‚Äì a fun, fast-paced biology quiz game! Test your VCE Biology knowledge in this free educational platformer designed for high school students.">
  <!-- Open Graph Meta Tags for Social Sharing -->
<meta property="og:title" content="Tadpole Trials ‚Äì A biology revision game">
<meta property="og:description" content="Answer Biology questions in this fun and challenging platformer. Play and learn at the same time!">
<meta property="og:image" content="https://svkhhnulgictmdvqvwte.supabase.co/storage/v1/object/public/social//SocialTadpoleTrials.jpg">
<meta property="og:url" content="https://tadpoletrials.1strankbiology.com">
<meta property="og:type" content="website">

<!-- Twitter Card Meta Tags -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Tadpole Trials ‚Äì A Biology Revision Game">
<meta name="twitter:description" content="Play Tadpole Trials to test your biology knowledge in a fun, quiz-based platformer!">
<meta name="twitter:image" content="https://svkhhnulgictmdvqvwte.supabase.co/storage/v1/object/public/social//SocialTadpoleTrials.jpg">

  <style>
/* Logo link styles */
header a {
  display: block;
  text-decoration: none;
  border: none;
  outline: none;
}

/* Add hover effect */
header a:hover {
  opacity: 0.9;
  transform: scale(1.01);
  transition: transform 0.2s ease;
}

.logo {
  max-width: 200px;
  width: 100%;
  height: auto;
  margin: 0 auto 10px;
  display: block;
}

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      touch-action: manipulation;
    }
    
    body {
      background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
      color: white;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      overflow-x: hidden;
    }
    
    header {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
  margin-bottom: 10px;
  width: 100%;
  max-width: 800px;
  padding-top: 5px;
}

    
    h1 {
      font-size: 2.5rem;
      margin-bottom: 5px;
      text-shadow: 0 0 15px rgba(0, 200, 255, 0.7);
      position: relative;
      display: inline-block;
    }
    
    .game-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  max-width: 800px;
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
}

/* Default (e.g. start screen, menus) */
.game-container:not(.game-active) {
  background: rgba(0, 20, 40, 0.85);
  border-radius: 15px;
  padding: 15px;
  box-shadow: 0 0 20px rgba(0, 100, 200, 0.5);
  border: 2px solid #00ccff;
}

/* During gameplay: strip visual styles */
.game-container.game-active {
  background: transparent;
  border: none;
  border-radius: 0;
  padding: 0;
  box-shadow: none;
}

    
    .screen {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      padding: 15px;
    }
    
    /* Start Screen - Original with small tweaks */
#startScreen {
  width: 100%;
  max-width: 800px;
  margin: 0 auto;
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

#startCanvas {
  width: 100%;
  height: auto; /* Changed from fixed height */
  min-height: 300px;
  max-height: 400px;
  aspect-ratio: 800/400; /* Maintain original aspect ratio */
  display: block;
}

#startBtn {
  margin-top: 20px;
  z-index: 2;
}

.controls-info {
  position: absolute;
  bottom: 80px;
  left: 0;
  width: 100%;
  text-align: center;
  color: rgba(255,255,255,0.8);
  font-size: 20px;
  pointer-events: none;
  padding: 0 10px;
  box-sizing: border-box;
}
    
    #gameCanvas {
      background: linear-gradient(to bottom, #87CEEB, #E0F7FA);
      border: 3px solid #00aaff;
      border-radius: 8px;
      display: block;
      margin: 0 auto;
      box-shadow: 0 0 15px rgba(0, 150, 255, 0.5);
      max-width: 800px;
      width: 100%;
      height: auto;
      image-rendering: pixelated;
      box-sizing: border-box;
    }
    
    #quiz, #scoreScreen, #finalScreen {
      background: rgba(10, 30, 60, 0.9);
      border-radius: 12px;
      padding: 20px;
      width: 100%;
      max-width: 600px;
      text-align: center;
    }
    
    #questionText {
      font-size: 1.2rem;
      margin-bottom: 20px;
      color: #aaffff;
      line-height: 1.4;
    }
    
    .optionBtn {
      width: 100%;
      padding: 12px;
      margin: 8px 0;
      background: linear-gradient(to right, #1e3c72, #2a5298);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: left;
      position: relative;
      overflow: hidden;
    }
    
    .optionBtn:active {
      transform: translateY(1px);
    }
    
    .optionBtn:before {
      content: "";
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 5px;
      background: #00ccff;
    }
    
    button {
      background: linear-gradient(to right, #00c6ff, #0072ff);
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 1.1rem;
      border-radius: 40px;
      cursor: pointer;
      transition: all 0.3s ease;
      margin: 8px;
      box-shadow: 0 4px 12px rgba(0, 100, 200, 0.4);
      font-weight: bold;
      min-width: 140px;
    }
    
    button:active {
      transform: translateY(1px);
    }
    
    .stats {
      display: flex;
      justify-content: space-around;
      width: 100%;
      padding: 12px;
      background: rgba(0, 30, 60, 0.7);
      border-radius: 8px;
      margin-bottom: 15px;
      font-size: 1rem;
      border: 1px solid #00aaff;
      flex-wrap: wrap;
    }
    
    .stats span {
      color: #aaffff;
      font-weight: bold;
    }
    
    .instructions {
      background: rgba(0, 40, 80, 0.7);
      padding: 15px;
      border-radius: 12px;
      margin: 15px 0;
      width: 100%;
      max-width: 600px;
      text-align: center;
      border: 1px solid #00ccff;
    }
    
    .instructions p {
      margin: 8px 0;
      line-height: 1.5;
    }
    
    .key {
      display: inline-block;
      background: rgba(0, 100, 200, 0.5);
      padding: 4px 8px;
      border-radius: 4px;
      margin: 0 4px;
      font-weight: bold;
      border: 1px solid #00aaff;
    }
    
    .brain-counter {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-size: 1.1rem;
      margin: 8px 0;
    }
    
    .brain-icon {
      color: #ff66cc;
      font-size: 1.5rem;
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    
    @keyframes jump {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-15px); }
    }
    
    .level-indicator {
      font-size: 1.2rem;
      margin: 12px 0;
      padding: 8px 16px;
      background: rgba(0, 100, 200, 0.3);
      border-radius: 40px;
      display: inline-block;
      border: 1px solid #00ccff;
    }
    
    .correct {
      background: linear-gradient(to right, #00b09b, #96c93d) !important;
    }
    
    .incorrect {
      background: linear-gradient(to right, #ff416c, #ff4b2b) !important;
    }
    
    .controls {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 15px;
    }
    
    .death-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(200, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
      opacity: 0;
      pointer-events: none;
    }
    
    .death-message {
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      font-size: 1.2rem;
    }
    
/* Mobile Controls */
#mobileControls {
  display: none;
  position: absolute;
  bottom: 20px;
  width: calc(100% - 30px);
  justify-content: space-between;
  z-index: 5;
  pointer-events: none;
}

@media (max-width: 768px) {
  .game-container.game-active #mobileControls {
    display: flex;
  }

  #mobileControls,
  #mobileControls button {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    touch-action: none;
    -webkit-tap-highlight-color: transparent;
  }
}


/* Visibility control */
@media (max-width: 768px) {
  .game-container.game-active #mobileControls {
    display: flex;
  }
}
    
    .dpad-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }
    
    .dpad-row {
      display: flex;
      gap: 5px;
    }
    
    .control-btn {
      width: 60px;
      height: 60px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      color: white;
      pointer-events: auto;
      touch-action: manipulation;
      user-select: none;
    }
    
    .jump-btn {
      width: 70px;
      height: 70px;
      background: rgba(0, 100, 200, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 16px;
      font-weight: bold;
      color: white;
      pointer-events: auto;
      touch-action: manipulation;
      user-select: none;
      align-self: flex-end;
      margin-right: 10px;
    }
    
    /* New shoot button */
    .shoot-btn {
      width: 70px;
      height: 70px;
      background: rgba(200, 0, 0, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 14px;
      font-weight: bold;
      color: white;
      pointer-events: auto;
      align-self: flex-end;
      margin-right: 10px;
      position: absolute;
      right: 10px;
      bottom: 90px;
    }
    
    /* Mobile-specific adjustments */
    @media (max-width: 768px) {
      h1 {
        font-size: 2rem;
      }
      
      h1:after {
        right: -35px;
        font-size: 1.8rem;
      }
      
      .game-container {
        padding: 10px;
        border-radius: 12px;
      }
      
      .screen {
        padding: 10px;
      }
      
      #quiz, #scoreScreen, #finalScreen {
        padding: 15px;
      }
      
      #questionText {
        font-size: 1.1rem;
      }
      
      .optionBtn {
        padding: 10px;
        font-size: 0.95rem;
      }
      
      button {
        padding: 10px 20px;
        font-size: 1rem;
        min-width: 120px;
      }
      
      .stats {
        flex-direction: column;
        gap: 8px;
      }
      
      .controls {
        flex-direction: column;
        gap: 10px;
      }
      
      
      /* Hide up arrow on mobile */
      #upBtn {
        display: none !important;
      }
    }
    
@media (max-width: 768px) {
  .controls-info {
    display: none !important;
  }
}


   /* Portrait-specific adjustments */
@media (max-width: 768px) and (orientation: portrait) {
  #startCanvas {
    min-height: 250px;
  }
  
  h1 {
    font-size: 2rem;
    white-space: nowrap; /* Prevent text wrapping */
  }
  
  .controls-info {
    font-size: 18px;
    bottom: 60px;
  }
}

@media (max-width: 480px) and (orientation: portrait) {
  h1 {
    font-size: 1.8rem;
  }
  
  .controls-info {
    font-size: 16px;
  }
}

    @media (max-width: 480px) {
      h1 {
        font-size: 1.8rem;
      }
      
      h1:after {
        right: -30px;
        font-size: 1.5rem;
      }
      
      .level-indicator {
        font-size: 1rem;
        padding: 6px 12px;
      }
      
      .control-btn {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }
      
      .jump-btn {
        width: 60px;
        height: 60px;
        font-size: 14px;
      }
      
      .shoot-btn {
        width: 60px;
        height: 60px;
        font-size: 12px;
        bottom: 80px;
      }
    }

   @media (max-width: 768px) and (orientation: portrait) {
  #mobileControls {
    position: static;
    margin-top: 10px;
    flex-direction: row;
    align-items: flex-end;
    justify-content: space-between;
    gap: 10px;
    width: 100%;
    padding: 0 10px 10px;
    pointer-events: auto;
  }

  .right-controls {
  display: flex; /* üëà REQUIRED for gap to work */
  flex-direction: column-reverse;
  align-items: flex-end;
  gap: 15px;
}


  .jump-btn,
  .shoot-btn {
    position: static !important;
    bottom: auto !important;
    margin: 0;
    width: 60px;
    height: 60px;
    font-size: 14px;
  }

  /* Add to your existing CSS */
.mode-selection {
  margin: 15px 0;
  text-align: center;
}

.mode-toggle {
  position: relative;
  display: inline-flex;
  align-items: center;
  cursor: pointer;
}

.mode-toggle input {
  opacity: 0;
  width: 0;
  height: 0;
}

.toggle-slider {
  position: relative;
  display: inline-block;
  width: 50px;
  height: 24px;
  background-color: #2a5298;
  border-radius: 24px;
  margin-right: 10px;
  transition: .4s;
}

.toggle-slider:before {
  content: "";
  position: absolute;
  height: 16px;
  width: 16px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  border-radius: 50%;
  transition: .4s;
}

input:checked + .toggle-slider {
  background-color: #4CAF50;
}

input:checked + .toggle-slider:before {
  transform: translateX(26px);
}

.toggle-label {
  color: white;
  font-size: 0.9rem;
  vertical-align: middle;
}
/* Default styling */
.copyright {
  text-align: center;
  font-size: 0.3rem;
  color: #ccc;
  margin-top: 15px;
}
}


  </style>
</head>
<body>
  <header>
  <a href="https://1strankbiology.com/" target="_blank" rel="noopener noreferrer">
    <img src="https://svkhhnulgictmdvqvwte.supabase.co/storage/v1/object/public/blacklogo//Logo%20Black.png" 
         alt="1st Rank Biology Logo" class="logo">
  </a>
  <h1>Tadpole Trials</h1>
  <p class="level-indicator">A biology revision game</p>
</header>
  
  <div class="game-container">
  <div id="startScreen" class="screen">
  <canvas id="startCanvas"></canvas>
  
  <!-- Add this new div for the mode selection -->
  <div class="mode-selection">
    <label class="mode-toggle">
      <input type="checkbox" id="juniorMode">
      <span class="toggle-slider"></span>
      <span class="toggle-label">Year 9 to 11 (default is 12)</span>
    </label>
  </div>
  
  <div class="controls-info">‚Üê ‚Üí to move ‚Ä¢ SPACE to jump ‚Ä¢ F/SHOOT to fire</div>
  <button id="startBtn">Start Game</button>
</div>

  <!-- ‚úÖ Moved Game Canvas & Overlay INSIDE container -->
  <canvas id="gameCanvas" width="800" height="400"></canvas>
  <div id="deathOverlay" class="death-overlay">
    <div class="death-message">Oh no! Press R to respawn</div>
  </div>

<div class="copyright">
  ¬© 2025 Aaron Gillespie
</div>


<div id="mobileControls">
  <div class="left-controls">
    <div class="dpad-container">
      <div class="dpad-row">
        <div class="control-btn" id="upBtn">‚Üë</div>
      </div>
      <div class="dpad-row">
        <div class="control-btn" id="leftBtn">‚Üê</div>
        <div class="control-btn" id="downBtn" style="visibility: hidden;"></div>
        <div class="control-btn" id="rightBtn">‚Üí</div>
      </div>
    </div>
  </div>

  <div class="right-controls">
  <div class="shoot-btn" id="shootBtn">SHOOT</div>
  <div class="jump-btn" id="jumpBtn">JUMP</div>
</div>
</div>


  <!-- Quiz Screen -->
  <div id="quiz" class="screen">
    <h2>Biology Quiz</h2>
    <div class="brain-counter">
      <span class="brain-icon">üß†</span> 
      <span id="collectedCount">0</span> Collected
    </div>
    <h3 id="questionText"></h3>
    <div id="optionsContainer"></div>
  </div>

  <!-- Score Screen -->
  <div id="scoreScreen" class="screen">
    <h2>Level Complete! üéâ</h2>
    <h3 id="scoreSummary"></h3>
    <div class="controls">
      <button id="retryBtn">üîÅ Retry Level</button>
      <button id="nextBtn">‚û° Next Level</button>
    </div>
  </div>

  <!-- Final Screen -->
  <div id="finalScreen" class="screen">
    <h2>Congratulations! üèÜ</h2>
    <h3 id="finalText"></h3>
    <button id="restartBtn">Play Again</button>
  </div>
</div>


  <script>
    // Mobile detection
    // More reliable mobile detection
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // Game state with enhanced physics and enemies
    const gameState = {
  currentLevel: 1,
  levels: [
    // First 2 levels - Easy
    { name: "Pond", questions: 10, collected: 0, brains: 5 },
    { name: "Forest", questions: 10, collected: 0, brains: 5 },
    
    // Next 2 levels - Medium
    { name: "Alien World", questions: 10, collected: 0, brains: 5 },
    { name: "Caves", questions: 10, collected: 0, brains: 5 },
    
    // Final 3 levels - Hard
    { name: "City", questions: 15, collected: 0, brains: 5 },
    { name: "Forest 2", questions: 15, collected: 0, brains: 5 },
    { name: "Finale", questions: 15, collected: 0, brains: 5 }
  ],
      player: {
        x: 100,
        y: 300,
        width: 30,
        height: 30,
        velX: 0,
        velY: 0,
        speed: isMobile ? 5.0 : 3.5,
        jumpPower: -12,
        gravity: 0.5,
        friction: 0.8,
        jumping: false,
        direction: 1,
        grounded: false,
        lives: 3
      },
      platforms: [],
      brains: [],
      enemies: [],
      playerProjectiles: [],
      enemyProjectiles: [],
      shootCooldown: 0,
      endFlag: null,
      collectedBrains: [],
      quizQuestions: [],
      usedQuestions: [], // Track all used questions across levels
      currentQuestion: 0,
      score: {
        correct: 0,
        total: 0
      },
      keys: {
        left: false,
        right: false,
        up: false,
        r: false,
        shoot: false
      },
      gameActive: false,
      cameraX: 0,
      levelWidth: 2000,
      isDead: false
    };

    // DOM elements
    const startScreen = document.getElementById('startScreen');
    const gameCanvas = document.getElementById('gameCanvas');
    const quizScreen = document.getElementById('quiz');
    const scoreScreen = document.getElementById('scoreScreen');
    const finalScreen = document.getElementById('finalScreen');
    const startBtn = document.getElementById('startBtn');
    const retryBtn = document.getElementById('retryBtn');
    const nextBtn = document.getElementById('nextBtn');
    const restartBtn = document.getElementById('restartBtn');
    const questionText = document.getElementById('questionText');
    const optionsContainer = document.getElementById('optionsContainer');
    const scoreSummary = document.getElementById('scoreSummary');
    const finalText = document.getElementById('finalText');
    const collectedCount = document.getElementById('collectedCount');
    const levelIndicator = document.querySelector('.level-indicator');
    const deathOverlay = document.getElementById('deathOverlay');
    const mobileControls = document.getElementById('mobileControls');
    const ctx = gameCanvas.getContext('2d');
    
    // Mobile control elements
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const upBtn = document.getElementById('upBtn');
    const jumpBtn = document.getElementById('jumpBtn');
    const shootBtn = document.getElementById('shootBtn');

// Start Screen Animation Code
const startCanvas = document.getElementById('startCanvas');
const startCtx = startCanvas.getContext('2d');

// Set canvas size
function resizeStartCanvas() {
  startCanvas.width = startCanvas.offsetWidth;
  startCanvas.height = startCanvas.offsetHeight;
}
resizeStartCanvas();
window.addEventListener('resize', resizeStartCanvas);

// Game state with mouse tracking
const startScreenState = {
  mouse: { x: 0, y: 0, isActive: false },
  screen: 'start',
  enemyX: startCanvas.width/2,
  enemyDirection: 1
};

// Mouse/touch tracking
startCanvas.addEventListener('mousemove', (e) => {
  const rect = startCanvas.getBoundingClientRect();
  startScreenState.mouse.x = e.clientX - rect.left;
  startScreenState.mouse.y = e.clientY - rect.top;
  startScreenState.mouse.isActive = true;
});

startCanvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const rect = startCanvas.getBoundingClientRect();
  startScreenState.mouse.x = e.touches[0].clientX - rect.left;
  startScreenState.mouse.y = e.touches[0].clientY - rect.top;
  startScreenState.mouse.isActive = true;
});

startCanvas.addEventListener('mouseout', () => {
  startScreenState.mouse.isActive = false;
});

// Animation loop
function animateStartScreen() {
  updateEnemyPosition();
  drawStartScreen();
  window._startScreenAnimFrame = requestAnimationFrame(animateStartScreen);
}

function updateEnemyPosition() {
  // Move enemy back and forth (slower)
  startScreenState.enemyX += startScreenState.enemyDirection * 1;
  
  // Reverse direction at edges
  if (startScreenState.enemyX > startCanvas.width - 100) {
    startScreenState.enemyDirection = -1;
  } else if (startScreenState.enemyX < 100) {
    startScreenState.enemyDirection = 1;
  }
}

// Main drawing function
function drawStartScreen() {
  const width = startCanvas.width;
  const height = startCanvas.height;
  const now = Date.now();
  
  // Clear canvas
  startCtx.clearRect(0, 0, width, height);
  
  // Draw background gradient
  const gradient = startCtx.createLinearGradient(0, 0, 0, height);
  gradient.addColorStop(0, '#1a2a6c');
  gradient.addColorStop(1, '#0a1a3a');
  startCtx.fillStyle = gradient;
  startCtx.fillRect(0, 0, width, height);
  
  // Draw bubbles
  startCtx.fillStyle = 'rgba(255,255,255,0.1)';
  for (let i = 0; i < 30; i++) {
    const seed = i * 100;
    const x = (seed * 31) % width;
    const y = (height + seed - (now / 50) % (height + 200));
    const size = 3 + (seed % 10);
    startCtx.beginPath();
    startCtx.arc(x, y, size, 0, Math.PI * 2);
    startCtx.fill();
  }
  
  
  // Draw the single horizontal enemy
  drawEnemy(startScreenState.enemyX, height/2 + 150);
  
  // Draw hero tadpole (eyes will track enemy or mouse)
  drawHeroTadpole(width/2, height/2 - 40);
}

function drawHeroTadpole(x, y) {
  const size = 100;
  const now = Date.now();
  
  // Body with gradient
  const bodyGradient = startCtx.createRadialGradient(
    x - size/4, y - size/4, size/8,
    x, y, size/2
  );
  bodyGradient.addColorStop(0, '#6bff6b');
  bodyGradient.addColorStop(1, '#4CAF50');
  startCtx.fillStyle = bodyGradient;
  startCtx.beginPath();
  startCtx.arc(x, y, size/2, 0, Math.PI * 2);
  startCtx.fill();
  
  // Animated tail
  const tailWiggle = Math.sin(now / 200) * 15;
  startCtx.beginPath();
  startCtx.moveTo(x + size/2, y);
  startCtx.quadraticCurveTo(
    x + size + 20, 
    y + tailWiggle, 
    x + size/1.5, 
    y + size/1.5 + tailWiggle/2
  );
  startCtx.quadraticCurveTo(
    x + size/2 + 10, 
    y + size/3, 
    x + size/2, 
    y
  );
  startCtx.fill();
  
  // Draw two cute, rounder, farther apart eyes
  const eyeWidth = size/10;
  const eyeHeight = size/10;
  const eyeY = y - size/8.5;
  const eyeSpacing = size/3.2; // even farther apart

  // Determine what to look at
  let lookX, lookY;
  if (startScreenState.mouse.isActive) {
    lookX = startScreenState.mouse.x;
    lookY = startScreenState.mouse.y;
  } else {
    // Look at enemy when not tracking mouse
    lookX = startScreenState.enemyX;
    lookY = startCanvas.height/2 + 100;
  }

  // Left eye (round)
  startCtx.fillStyle = 'white';
  startCtx.beginPath();
  startCtx.arc(x - eyeSpacing/2, eyeY, eyeWidth, 0, Math.PI * 2);
  startCtx.fill();

  // Right eye (round)
  startCtx.beginPath();
  startCtx.arc(x + eyeSpacing/2, eyeY, eyeWidth, 0, Math.PI * 2);
  startCtx.fill();

  // Eye pupils (bigger, more centered for cuteness)
  startCtx.fillStyle = 'black';

  // Left pupil
  let pupilX = x - eyeSpacing/2 + (lookX - x) / 80;
  let pupilY = eyeY + (lookY - y) / 80;
  startCtx.beginPath();
  startCtx.arc(pupilX, pupilY, eyeWidth/2.2, 0, Math.PI * 2);
  startCtx.fill();

  // Right pupil
  pupilX = x + eyeSpacing/2 + (lookX - x) / 80;
  startCtx.beginPath();
  startCtx.arc(pupilX, pupilY, eyeWidth/2.2, 0, Math.PI * 2);
  startCtx.fill();

  // Add a little white shine for extra cuteness
  startCtx.fillStyle = 'white';
  startCtx.globalAlpha = 0.7;
  startCtx.beginPath();
  startCtx.arc(x - eyeSpacing/2 - eyeWidth/4, eyeY - eyeWidth/4, eyeWidth/5, 0, Math.PI * 2);
  startCtx.fill();
  startCtx.beginPath();
  startCtx.arc(x + eyeSpacing/2 - eyeWidth/4, eyeY - eyeWidth/4, eyeWidth/5, 0, Math.PI * 2);
  startCtx.fill();
  startCtx.globalAlpha = 1.0;
  
  // Cute mouth (smaller, higher, more smiley)
  const mouthHappy = startScreenState.mouse.isActive || 
    (Math.abs(startScreenState.enemyX - x) < 150 && Math.abs((startCanvas.height/2 + 100) - y) < 150);

  startCtx.strokeStyle = '#333';
  startCtx.lineWidth = 2.2;
  startCtx.beginPath();
  if (mouthHappy) {
    startCtx.arc(x, y + size/7.5, size/15, 0, Math.PI, false); // Big smile
  } else {
    startCtx.arc(x, y + size/7.5, size/15, Math.PI * 0.1, Math.PI * 0.9); // Neutral
  }
  startCtx.stroke();
}

function drawEnemy(x, y) {
  const width = 60;
  const height = 40;
  
  // Draw body
  startCtx.fillStyle = '#FF0000';
  startCtx.fillRect(x - width/2, y - height/2, width, height);
  
  // Draw eyes (facing direction of movement)
  startCtx.fillStyle = 'white';
  startCtx.beginPath();
  
  const eyeOffset = startScreenState.enemyDirection > 0 ? 10 : 5;
  
  startCtx.arc(x - width/2 + eyeOffset, y - height/2 + 15, 5, 0, Math.PI * 2);
  startCtx.arc(x + width/2 - eyeOffset, y - height/2 + 15, 5, 0, Math.PI * 2);
  startCtx.fill();
  
  // Draw pupils
  startCtx.fillStyle = 'black';
  startCtx.beginPath();
  startCtx.arc(x - width/2 + eyeOffset, y - height/2 + 15, 3, 0, Math.PI * 2);
  startCtx.arc(x + width/2 - eyeOffset, y - height/2 + 15, 3, 0, Math.PI * 2);
  startCtx.fill();
}

function showScreen(screen) {
  // Hide all screens
  startScreen.style.display = 'none';
  gameCanvas.style.display = 'none';
  quizScreen.style.display = 'none';
  scoreScreen.style.display = 'none';
  finalScreen.style.display = 'none';
  startCanvas.style.display = 'none';
  document.querySelector('.controls-info')?.style.setProperty('display', 'none');

  // Show requested screen
  screen.style.display = 'flex';

  // Hide copyright if quiz or score screen, show otherwise
  const copyright = document.querySelector('.copyright');
  if (screen === quizScreen || screen === scoreScreen) {
    copyright.style.display = 'none';
  } else {
    copyright.style.display = 'block';
  }

  // Toggle game-active class
  const gameContainer = document.querySelector('.game-container');
  gameContainer.classList.toggle('game-active', screen === gameCanvas);

  // Special handling for start screen
  if (screen === startScreen) {
    startCanvas.style.display = 'block';
    document.querySelector('.controls-info')?.style.setProperty('display', 'block');
    if (!window._startScreenAnimFrame) {
      animateStartScreen();
    }
  } else {
    if (window._startScreenAnimFrame) {
      cancelAnimationFrame(window._startScreenAnimFrame);
      window._startScreenAnimFrame = null;
    }
  }
}


    // Initialize game
    function init() {
  // Ensure game canvas is always 800x400 for crisp scaling
  function resizeGameCanvas() {
    gameCanvas.width = 800;
    gameCanvas.height = 400;
  }
  resizeGameCanvas();
  // Start the start screen animation
  animateStartScreen();

  startBtn.addEventListener('click', startGame);
  retryBtn.addEventListener('click', retryLevel);
  nextBtn.addEventListener('click', nextLevel);
  restartBtn.addEventListener('click', restartGame);
  
  document.addEventListener('keydown', handleKeyDown);
  document.addEventListener('keyup', handleKeyUp);
  
  if (isMobile) {
        const buttonActions = {
          leftBtn: 'left',
          rightBtn: 'right',
          upBtn: 'up',
          jumpBtn: 'up',
          shootBtn: 'shoot'
        };

        Object.entries(buttonActions).forEach(([id, key]) => {
          const btn = document.getElementById(id);

          // Touch control logic
          btn.addEventListener('touchstart', () => gameState.keys[key] = true);
          btn.addEventListener('touchend', () => gameState.keys[key] = false);

          // Prevent unwanted mobile behavior
          btn.addEventListener('contextmenu', e => e.preventDefault());
          btn.addEventListener('selectstart', e => e.preventDefault());
          btn.addEventListener('touchstart', e => e.preventDefault(), { passive: false });

          // Optional: removes grey highlight on tap
          btn.style.webkitTapHighlightColor = 'transparent';
        });
      }
      
      // Initial screen setup
      showScreen(startScreen);
      deathOverlay.style.display = 'none';
    }

    // Start the game
    function startGame() {
      resetGameState();
      showScreen(gameCanvas);
      setupLevel(1);
      gameState.gameActive = true;
      requestAnimationFrame(gameLoop);
    }

    // Set up a level
    function setupLevel(level) {
      gameState.currentLevel = level;
      gameState.player = {
        x: 100,
        y: 300,
        width: 30,
        height: 30,
        velX: 0,
        velY: 0,
        speed: isMobile ? 5.0 : 3.5,
        jumpPower: -12,
        gravity: 0.5,
        friction: 0.6,
        jumping: false,
        direction: 1,
        grounded: false,
        lives: 3
      };
      gameState.collectedBrains = [];
      gameState.platforms = [];
      gameState.brains = [];
      gameState.enemies = [];
      gameState.playerProjectiles = [];
      gameState.enemyProjectiles = [];
      gameState.quizQuestions = [];
      // Only reset usedQuestions if starting a new game (level 1)
      if (level === 1) {
        gameState.usedQuestions = [];
      }
      gameState.score = { correct: 0, total: 0 };
      gameState.cameraX = 0;
      gameState.isDead = false;
      gameState.shootCooldown = 0;
      
      levelIndicator.textContent = `Level ${level}: ${gameState.levels[level-1].name}`;
      
      // Create platforms
      gameState.platforms.push({x: 0, y: 350, width: gameState.levelWidth, height: 20}); // Ground
      
      // Level-specific configurations
      if (level === 1) {
        gameState.levelWidth = 2000;
        
        // Add platforms
        gameState.platforms.push({x: 200, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 400, y: 230, width: 100, height: 20});
        gameState.platforms.push({x: 600, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 800, y: 230, width: 100, height: 20});
        gameState.platforms.push({x: 1000, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 1200, y: 230, width: 100, height: 20});
        gameState.platforms.push({x: 1400, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 1600, y: 230, width: 100, height: 20});
        gameState.platforms.push({x: 1800, y: 280, width: 60, height: 20});
        
        // Add 5 brains
         gameState.brains.push({x: 250, y: 250, collected: false});
  gameState.brains.push({x: 600, y: 210, collected: false});
  gameState.brains.push({x: 950, y: 250, collected: false});
  gameState.brains.push({x: 1300, y: 210, collected: false});
  gameState.brains.push({x: 1650, y: 210, collected: false});
        
        // Add enemies
        gameState.enemies.push({
          x: 500, y: 200, width: 30, height: 30, 
          velX: 1, minX: 450, maxX: 700,
          type: 'ground',
          alive: true
        });
        gameState.enemies.push({
          x: 1200, y: 180, width: 30, height: 30, 
          velX: -1.5, minX: 1100, maxX: 1400,
          type: 'ground',
          alive: true
        });
        gameState.enemies.push({
  x: 900, y: 320, width: 30, height: 30, 
  velX: 0.8, minX: 800, maxX: 1000,
  type: 'ground',
  alive: true
});


      } else if (level === 2) {
        gameState.levelWidth = 2500;
        
        // Add platforms
        gameState.platforms.push({x: 200, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 400, y: 230, width: 100, height: 20});
        gameState.platforms.push({x: 650, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 800, y: 200, width: 100, height: 20});
        gameState.platforms.push({x: 1000, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 1200, y: 230, width: 100, height: 20});
        gameState.platforms.push({x: 1400, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 1600, y: 230, width: 100, height: 20});
        gameState.platforms.push({x: 1800, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 2000, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 2200, y: 340, width: 300, height: 30});
        
        // Add 5 brains
          gameState.brains.push({x: 300, y: 230, collected: false});
  gameState.brains.push({x: 750, y: 180, collected: false});
  gameState.brains.push({x: 1200, y: 210, collected: false});
  gameState.brains.push({x: 1700, y: 180, collected: false});
  gameState.brains.push({x: 2200, y: 300, collected: false});
        
        // Add enemies
        gameState.enemies.push({
          x: 600, y: 200, width: 30, height: 30, 
          velX: 1.2, minX: 500, maxX: 800,
          type: 'ground',
          alive: true
        });
        gameState.enemies.push({
          x: 1400, y: 180, width: 30, height: 30, 
          velX: -1.7, minX: 1300, maxX: 1600,
          type: 'ground',
          alive: true
        });
        // Vertical moving enemy
        gameState.enemies.push({
          x: 1800, y: 150, width: 30, height: 30,
          velY: 1.5, minY: 100, maxY: 250,
          type: 'vertical',
          alive: true
        });
        gameState.enemies.push({
          x: 900, y: 150, width: 30, height: 30,
          velY: 1.5, minY: 100, maxY: 250,
          type: 'vertical',
          alive: true
        });
// Ranged enemy
        gameState.enemies.push({
          x: 1000, y: 150, width: 30, height: 30, 
          velX: 0, attackTimer: 90, attackRange: 300,
          type: 'ranged',
          alive: true
        });
       

      } else if (level === 3) {
        gameState.levelWidth = 3000;
        
        // Add platforms
        gameState.platforms.push({x: 200, y: 280, width: 70, height: 20});
        gameState.platforms.push({x: 400, y: 230, width: 70, height: 20});
        gameState.platforms.push({x: 600, y: 180, width: 70, height: 20});
        gameState.platforms.push({x: 800, y: 230, width: 70, height: 20});
        gameState.platforms.push({x: 1000, y: 280, width: 70, height: 20});
        gameState.platforms.push({x: 1200, y: 230, width: 70, height: 20});
        gameState.platforms.push({x: 1400, y: 180, width: 70, height: 20});
        gameState.platforms.push({x: 1600, y: 230, width: 70, height: 20});
        gameState.platforms.push({x: 1800, y: 280, width: 70, height: 20});
        gameState.platforms.push({x: 2000, y: 230, width: 70, height: 20});
        gameState.platforms.push({x: 2200, y: 180, width: 70, height: 20});
        gameState.platforms.push({x: 2400, y: 230, width: 70, height: 20});
        gameState.platforms.push({x: 2600, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 2800, y: 340, width: 200, height: 20});

          // 5 brains (strategic placement on narrow platforms)
  gameState.brains.push({x: 250, y: 250, collected: false});
  gameState.brains.push({x: 650, y: 160, collected: false}); // Requires precise jump
  gameState.brains.push({x: 1250, y: 160, collected: false});
  gameState.brains.push({x: 1850, y: 250, collected: false});
  gameState.brains.push({x: 2350, y: 160, collected: false}); // Challenge brain

        
        // Add enemies
        gameState.enemies.push({
          x: 700, y: 150, width: 30, height: 30, 
          velX: 1.5, minX: 600, maxX: 900,
          type: 'ground',
          alive: true
        });
        gameState.enemies.push({
          x: 1500, y: 150, width: 30, height: 30, 
          velX: -1.8, minX: 1400, maxX: 1700,
          type: 'ground',
          alive: true
        });
        // Vertical moving enemy
        gameState.enemies.push({
          x: 1800, y: 150, width: 30, height: 30,
          velY: 1.5, minY: 100, maxY: 250,
          type: 'vertical',
          alive: true
        });
        gameState.enemies.push({
          x: 900, y: 150, width: 30, height: 30,
          velY: 1.5, minY: 100, maxY: 250,
          type: 'vertical',
          alive: true
        });
        // Ranged enemy
        gameState.enemies.push({
          x: 2300, y: 150, width: 30, height: 30, 
          velX: 0, attackTimer: 60, attackRange: 300,
          type: 'ranged',
          alive: true
        });
        gameState.enemies.push({
          x: 1100, y: 150, width: 30, height: 30, 
          velX: 0, attackTimer: 60, attackRange: 300,
          type: 'ranged',
          alive: true
        });


        } else if (level === 4) {
        gameState.levelWidth = 3000;
        
       // Level 4 - Optimized Platform Layout
gameState.platforms = [
  // Starting area
  {x: 50, y: 330, width: 220, height: 25},   // Starter platform
  {x: 320, y: 280, width: 140, height: 25},  // First slope

  // First challenge section
  {x: 520, y: 330, width: 120, height: 25},
  {x: 700, y: 280, width: 100, height: 25},  // First jump down
  {x: 900, y: 330, width: 120, height: 25},  // Landing platform

  // Middle section 
  {x: 1100, y: 280, width: 100, height: 25}, // Second jump down
  {x: 1350, y: 330, width: 120, height: 25}, // Landing

  // Upper section
  {x: 1550, y: 280, width: 100, height: 25}, // Third jump down
  {x: 1750, y: 330, width: 160, height: 25}, // Landing

  // Final stretch
  {x: 2000, y: 280, width: 130, height: 25}, // Final drop
  {x: 2300, y: 330, width: 260, height: 25}, // Main final platform
  {x: 2700, y: 330, width: 250, height: 25}  // Victory landing
];

// Strategic safety nets (only where needed)
gameState.safetyNets = [
  {x: 650, y: 420, width: 300, height: 25},  // Below first challenge
  {x: 1050, y: 420, width: 300, height: 25}, // Below middle section
  {x: 2500, y: 420, width: 500, height: 25}  // Final safety
];

// Brains placed on main path platforms
gameState.brains = [
  {x: 150, y: 300, collected: false},       // Starter
  {x: 400, y: 250, collected: false},       // First slope
  {x: 750, y: 250, collected: false},       // First challenge
  {x: 1200, y: 250, collected: false},      // Middle section
  {x: 2400, y: 300, collected: false}       // Final reward
];

// Adjusted brain positions
gameState.brains = [
  {x: 150, y: 300, collected: false},      // Starter brain
  {x: 400, y: 250, collected: false},      // Easy slope brain
  {x: 750, y: 250, collected: false},      // First challenge
  {x: 1150, y: 250, collected: false},     // Middle section
  {x: 2400, y: 300, collected: false}      // Final reward
];

// Tamer enemies
gameState.enemies = [
  {
    x: 600, y: 250, width: 35, height: 35, // Bigger hitbox = easier to avoid
    velX: 0.8, minX: 550, maxX: 750,       // Slower
    type: 'ground',
    alive: true
  },
  {
    x: 1200, y: 230, width: 35, height: 35,
    velY: 0.7, minY: 210, maxY: 270,       // Reduced range
    type: 'vertical',
    alive: true
  }
];
// Ranged enemy
        gameState.enemies.push({
          x: 2300, y: 100, width: 30, height: 30, 
          velX: 0, attackTimer: 60, attackRange: 300,
          type: 'ranged',
          alive: true
        });

  } else if (level === 5) {
    gameState.levelWidth = 3200; // Slightly longer for new enemies
    
    // More aggressive platform layout with narrower platforms
    gameState.platforms = [
        // Starting area (tighter)
        {x: 50, y: 330, width: 180, height: 20},   // Starter platform
        {x: 300, y: 280, width: 100, height: 20},  // First drop (narrower)

        // First challenge section (more enemies)
        {x: 500, y: 330, width: 85, height: 20},
        {x: 700, y: 280, width: 75, height: 20},   // Precise landing
        {x: 900, y: 330, width: 80, height: 20},   // Now more dangerous

        // Middle section (added complexity)
        {x: 1100, y: 280, width: 75, height: 20},
        {x: 1350, y: 330, width: 80, height: 20},
        {x: 1550, y: 260, width: 65, height: 20},  // New low platform

        // Upper section (more vertical)
        {x: 1750, y: 210, width: 75, height: 20},
        {x: 1950, y: 290, width: 100, height: 20},  // Gap jump
        {x: 2200, y: 330, width: 100, height: 20},

        // Final stretch (more challenging)
        {x: 2500, y: 280, width: 70, height: 20},   // Platform 10
{x: 2650, y: 310, width: 65, height: 20},   // NEW mid-way platform (small, requires precision)
{x: 2800, y: 330, width: 300, height: 20},  // Platform 11 (now reachable)
    ];

    // Reduced safety nets (only critical spots)
    gameState.safetyNets = [
        {x: 800, y: 420, width: 200, height: 20},
        {x: 2600, y: 420, width: 400, height: 20}
    ];

    // Brains moved to riskier positions
    gameState.brains = [
        {x: 350, y: 250, collected: false},      // After first drop
        {x: 730, y: 250, collected: false},      // Requires enemy dodging
        {x: 1370, y: 300, collected: false},     // Above moving enemy
        {x: 1770, y: 170, collected: false},     // High-risk position
        {x: 2550, y: 250, collected: false}      // Final challenge
    ];

    // More numerous and aggressive enemies
    gameState.enemies = [
        // First section enemies
        {
            x: 400, y: 230, width: 30, height: 30,
            velX: 1.5, minX: 350, maxX: 600,
            type: 'ground',
            alive: true
        },
        {
            x: 800, y: 250, width: 30, height: 30,
            velY: 1.2, minY: 230, maxY: 350,
            type: 'vertical',
            alive: true
        },
        
        // Middle section ambush
        {
            x: 1200, y: 200, width: 25, height: 40,
            velX: 2.0, minX: 1100, maxX: 1400,
            type: 'ground',
            alive: true
        },
        {
            x: 1500, y: 210, width: 30, height: 30,
            velX: 0, attackTimer: 40, attackRange: 350,
            type: 'ranged',
            alive: true
        },
        
        // Final stretch challenges
        {
            x: 2000, y: 250, width: 30, height: 30,
            velX: 1.8, minX: 1900, maxX: 2300,
            type: 'ground',
            alive: true
        },
        {
            x: 2400, y: 200, width: 30, height: 50,
            velY: 1.5, minY: 180, maxY: 300,
            type: 'vertical',
            alive: true
        }
    ];

    // New environmental hazard
    gameState.hazards = [
        {x: 1600, y: 400, width: 400, height: 20, type: 'lava'},
        {x: 2100, y: 400, width: 300, height: 20, type: 'spikes'}
    ];

  
  } else if (level === 6) {
  gameState.levelWidth = 4000;
  
  // Platform Layout - Demanding but achievable jumps
  gameState.platforms = [
    // Starting section (warm-up)
    {x: 0, y: 380, width: 200, height: 20},
    {x: 200, y: 380, width: 100, height: 20},
    {x: 400, y: 350, width: 80, height: 20},
    
    // First challenge cluster
    {x: 600, y: 320, width: 60, height: 20},
    {x: 800, y: 290, width: 60, height: 20},  // First precision jump
    {x: 1000, y: 320, width: 80, height: 20}, // Landing after enemy gauntlet
    
    // Elevation climb
    {x: 1180, y: 280, width: 140, height: 20},
    {x: 1280, y: 280, width: 120, height: 20},
    {x: 1500, y: 240, width: 60, height: 20},
    {x: 1650, y: 200, width: 100, height: 20}, // Highest point
    
    // Descending maze
    {x: 1780, y: 240, width: 80, height: 20},
    {x: 2000, y: 280, width: 100, height: 20},
    {x: 2150, y: 280, width: 140, height: 20},
    {x: 2300, y: 300, width: 140, height: 20},
    {x: 2500, y: 320, width: 120, height: 20},
    {x: 2700, y: 320, width: 180, height: 20},
    {x: 2890, y: 300, width: 180, height: 20},
    
    // Final stretch
    {x: 3200, y: 320, width: 210, height: 20}, // Safe zone
    {x: 3400, y: 320, width: 210, height: 20}, // Safe zone
    {x: 3300, y: 320, width: 210, height: 20}, // Safe zone
    {x: 3400, y: 320, width: 190, height: 20}, // Safe zone
    {x: 3600, y: 350, width: 350, height: 20}  // Exit
  ];

  // Brains - Require risk or skill
  gameState.brains = [
    {x: 820, y: 270, collected: false},  // Above first enemy cluster
    {x: 1520, y: 225, collected: false}, // At elevation peak
    {x: 2020, y: 225, collected: false}, // Descending maze
    {x: 2600, y: 300, collected: false}, // Before final stretch
    {x: 3050, y: 260, collected: false}  // Precarious final brain
  ];

  // Enemies - Enhanced from Level 5 but fair
  gameState.enemies = [
    // Fast ground patrols
    {
      x: 300, y: 310, width: 30, height: 40, // Taller hitbox
      velX: 3.0, minX: 200, maxX: 700,      // Faster
      type: 'ground',
      alive: true
    },
    {
      x: 1100, y: 280, width: 30, height: 40,
      velX: -3.0, minX: 900, maxX: 1400,
      type: 'ground',
      alive: true
    },
    
    // Vertical threats
    {
      x: 1700, y: 150, width: 30, height: 50,
      velY: 3.0, minY: 150, maxY: 300,      // Faster + extended range
      type: 'vertical',
      alive: true
    },
    {
      x: 2500, y: 150, width: 30, height: 50,
      velY: 2.8, minY: 150, maxY: 350,
      type: 'vertical',
      alive: true
    },
    
    // Ranged enemy
    {
      x: 2300, y: 200, width: 30, height: 30,
      velX: 0, attackTimer: 15, attackRange: 350, // Faster attacks
      type: 'ranged',
      alive: true
    },
    
    // Final ambush
    {
      x: 3200, y: 280, width: 40, height: 40, // Larger
      velX: 2.5, minX: 3000, maxX: 3400,
      type: 'ground',
      alive: true
    }
  ];

  // Hazards - Punish mistakes
  gameState.hazards = [
    {x: 700, y: 400, width: 600, height: 50, type: 'spikes'},  // Below first cluster
    {x: 1800, y: 400, width: 500, height: 50, type: 'lava'},   // Under elevation
    {x: 2800, y: 400, width: 800, height: 50, type: 'void'}    // Final stretch
  ];

} else if (level === 7) {
    gameState.levelWidth = 4000;
    
    // Level 7 - Final Challenge (Balanced Design)
    gameState.platforms = [
        // Starting area (safe zone)
        {x: 50, y: 350, width: 250, height: 25},
        
        // First section - gentle warm-up
        {x: 350, y: 320, width: 100, height: 25},
        {x: 520, y: 290, width: 100, height: 25},
        {x: 700, y: 320, width: 120, height: 25},
        
        // Second section - first challenges
        {x: 900, y: 280, width: 90, height: 25},  // First precision jump
        {x: 1100, y: 320, width: 120, height: 25},
        {x: 1300, y: 270, width: 80, height: 25}, // Skill jump
        
        // Third section - elevation changes
        {x: 1500, y: 320, width: 120, height: 25},
        {x: 1700, y: 280, width: 100, height: 25},
        {x: 1900, y: 320, width: 140, height: 25},
        
        // Fourth section - platform gauntlet
        {x: 2200, y: 290, width: 80, height: 25},
        {x: 2400, y: 320, width: 100, height: 25},
        {x: 2600, y: 280, width: 80, height: 25},
        {x: 2800, y: 320, width: 120, height: 25},
        
        // Final stretch
        {x: 3100, y: 290, width: 90, height: 25}, // Final challenge
        {x: 3300, y: 320, width: 150, height: 25},
        {x: 3600, y: 320, width: 300, height: 25}  // Victory platform
    ];

    // Safety nets at key drop points
    gameState.safetyNets = [
        {x: 800, y: 420, width: 300, height: 25},  // After first section
        {x: 1800, y: 420, width: 300, height: 25}, // Middle safety
        {x: 3000, y: 420, width: 400, height: 25}  // Final safety
    ];

    // Brains - 5 total, progressively harder to reach
    gameState.brains = [
        {x: 200, y: 320, collected: false},       // Early easy brain
        {x: 750, y: 270, collected: false},       // Requires first jump
        {x: 1600, y: 260, collected: false},      // Mid-level challenge
        {x: 2500, y: 260, collected: false},      // Platforming skill
        {x: 3400, y: 290, collected: false}       // Final challenge brain
    ];

    // Enemies - Balanced final challenge
    gameState.enemies = [
        // First enemy - simple ground patrol
        {
            x: 600, y: 270, width: 35, height: 35,
            velX: 1.0, minX: 550, maxX: 800,
            type: 'ground',
            alive: true
        },
        // Second enemy - vertical challenge
        {
            x: 1500, y: 200, width: 35, height: 35,
            velY: 1.0, minY: 180, maxY: 300,
            type: 'vertical',
            alive: true
        },
        // Third enemy - faster ground patrol
        {
            x: 2200, y: 250, width: 35, height: 35,
            velX: 1.5, minX: 2100, maxX: 2500,
            type: 'ground',
            alive: true
        },
        // Ranged enemy
    {
      x: 900, y: 260, width: 30, height: 30,
      velX: 0, attackTimer: 20, attackRange: 300, // Faster attacks
      type: 'ranged',
      alive: true
    },
    {
      x: 1500, y: 300, width: 30, height: 30,
      velX: 0, attackTimer: 20, attackRange: 300, // Faster attacks
      type: 'ranged',
      alive: true
    },
        // Final enemy - ranged attacker
        {
            x: 3000, y: 250, width: 35, height: 35,
            velX: 0, attackTimer: 15, attackRange: 350,
            type: 'ranged',
            alive: true
        }
    ];

      }
      
      
      // Add end flag at the end of the level
      gameState.endFlag = {x: gameState.levelWidth - 100, y: 270, width: 30, height: 80};
    }

    // Game loop
    function gameLoop() {
      if (!gameState.gameActive) return;
      
      update();
      draw();
      
      requestAnimationFrame(gameLoop);
    }

    // Update game state with fixed physics
    function update() {
      const player = gameState.player;
      
      // Player is dead - wait for respawn
      if (gameState.isDead) {
        if (gameState.keys.r) {
          respawnPlayer();
        }
        return;
      }
      
      // Apply gravity if not grounded
      if (!player.grounded) {
        player.velY += player.gravity;
      } else {
        player.velY = 0;
      }
      
      // Handle horizontal movement with friction
      if (gameState.keys.left) {
        player.velX = -player.speed;
        player.direction = -1;
      } else if (gameState.keys.right) {
        player.velX = player.speed;
        player.direction = 1;
      } else {
        player.velX *= player.friction;
        if (Math.abs(player.velX) < 0.1) player.velX = 0;
      }
      
      // Jumping - only when grounded
      if (gameState.keys.up && player.grounded) {
        player.velY = player.jumpPower;
        player.grounded = false;
      }
      
      // Shooting
      if (gameState.keys.shoot && gameState.shootCooldown <= 0) {
        gameState.playerProjectiles.push({
          x: player.x + player.width * player.direction,
          y: player.y + player.height/2,
          width: 15,
          height: 15,
          velX: 7 * player.direction,
          distance: 0,
          range: 400
        });
        gameState.shootCooldown = 60; // Cooldown frames
      }
      
      // Update position
      player.x += player.velX;
      player.y += player.velY;
      
      // Boundary checks (left/right)
      if (player.x < 0) {
        player.x = 0;
        player.velX = 0;
      }
      if (player.x > gameState.levelWidth - player.width) {
        player.x = gameState.levelWidth - player.width;
        player.velX = 0;
      }
      
      // Boundary check (bottom) - prevent falling through
      if (player.y > gameCanvas.height + 100) {
        playerDie();
        return;
      }
      
      // Improved platform collision detection
      player.grounded = false;
      for (const platform of gameState.platforms) {
        // Check if player is intersecting with platform vertically
        if (player.x < platform.x + platform.width &&
            player.x + player.width > platform.x &&
            player.y + player.height >= platform.y &&
            player.y < platform.y) {
          
          // Check if player was above the platform in previous frame
          if (player.y + player.height - player.velY <= platform.y) {
            player.y = platform.y - player.height;
            player.velY = 0;
            player.grounded = true;
          }
        }
      }
      
      // Update camera position to follow player
      gameState.cameraX = player.x - gameCanvas.width / 2;
      gameState.cameraX = Math.max(0, Math.min(gameState.levelWidth - gameCanvas.width, gameState.cameraX));
      
      // Brain collection
      for (const brain of gameState.brains) {
        if (!brain.collected) {
          const dx = Math.abs(player.x + player.width/2 - (brain.x + 10));
          const dy = Math.abs(player.y + player.height/2 - (brain.y + 10));
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 20) {
            brain.collected = true;
            gameState.collectedBrains.push(brain);
            gameState.levels[gameState.currentLevel-1].collected++;
          }
        }
      }
      
      // Update enemies
      for (const enemy of gameState.enemies) {
        if (enemy.alive) {
          // Move enemy based on type
          if (enemy.type === 'ground') {
            enemy.x += enemy.velX;
            if (enemy.x <= enemy.minX || enemy.x + enemy.width >= enemy.maxX) {
              enemy.velX *= -1;
            }
          }
          else if (enemy.type === 'vertical') {
            enemy.y += enemy.velY;
            if (enemy.y <= enemy.minY || enemy.y >= enemy.maxY) {
              enemy.velY *= -1;
            }
          }
          else if (enemy.type === 'ranged') {
            // Update attack timer
            enemy.attackTimer--;
            if (enemy.attackTimer <= 0) {
              // Calculate direction to player
              const dx = player.x - enemy.x;
              const dy = player.y - enemy.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              // Only shoot if player is in range
              if (distance < enemy.attackRange) {
                // Normalize direction
                const velX = dx / distance * 3;
                const velY = dy / distance * 3;
                
                // Create projectile
                gameState.enemyProjectiles.push({
                  x: enemy.x + enemy.width/2,
                  y: enemy.y + enemy.height/2,
                  width: 10,
                  height: 10,
                  velX: velX,
                  velY: velY,
                  distance: 0,
                  range: enemy.attackRange
                });
                
                // Reset attack timer
                enemy.attackTimer = 120;
              }
            }
          }
          
          // Enemy collision with player
          if (
            player.x < enemy.x + enemy.width &&
            player.x + player.width > enemy.x &&
            player.y < enemy.y + enemy.height &&
            player.y + player.height > enemy.y
          ) {
            // Check if player is jumping on enemy
            if (player.y + player.height < enemy.y + enemy.height/2 && player.velY > 0) {
              // Player lands on enemy
              enemy.alive = false;
              player.velY = -10; // bounce
            } else {
              // Player touched enemy from side or below
              playerDie();
              return;
            }
          }
        }
      }
      
      // Update projectiles
      updateProjectiles();
      
      // End flag collision
      if (
        player.x < gameState.endFlag.x + gameState.endFlag.width &&
        player.x + player.width > gameState.endFlag.x &&
        player.y < gameState.endFlag.y + gameState.endFlag.height &&
        player.y + player.height > gameState.endFlag.y
      ) {
        endLevel();
      }
      
      // Update shoot cooldown
      if (gameState.shootCooldown > 0) {
        gameState.shootCooldown--;
      }
    }
    
    // Update projectiles
    function updateProjectiles() {
      // Player projectiles
      for (let i = gameState.playerProjectiles.length - 1; i >= 0; i--) {
        const p = gameState.playerProjectiles[i];
        p.x += p.velX;
        p.distance += Math.abs(p.velX);
        
        // Check enemy collisions
        let hit = false;
        for (const enemy of gameState.enemies) {
          if (enemy.alive && 
              p.x < enemy.x + enemy.width &&
              p.x + p.width > enemy.x &&
              p.y < enemy.y + enemy.height &&
              p.y + p.height > enemy.y) {
            enemy.alive = false;
            hit = true;
            break;
          }
        }
        
        // Remove projectiles that hit or exceed range
        if (hit || p.distance > p.range) {
          gameState.playerProjectiles.splice(i, 1);
        }
      }
      
      // Enemy projectiles
      for (let i = gameState.enemyProjectiles.length - 1; i >= 0; i--) {
        const p = gameState.enemyProjectiles[i];
        p.x += p.velX;
        p.y += p.velY;
        p.distance += Math.sqrt(p.velX * p.velX + p.velY * p.velY);
        
        // Check player collision
        const player = gameState.player;
        if (p.x < player.x + player.width &&
            p.x + p.width > player.x &&
            p.y < player.y + player.height &&
            p.y + p.height > player.y) {
          playerDie();
          gameState.enemyProjectiles.splice(i, 1);
        } 
        // Remove projectiles that exceed range
        else if (p.distance > p.range) {
          gameState.enemyProjectiles.splice(i, 1);
        }
      }
    }

    function playerDie() {
      if (gameState.player.lives <= 0) return;

      gameState.player.lives--;

      if (gameState.player.lives <= 0) {
        gameState.player.lives = 0;
        showRestartMessage("üíÄ Out of lives! Restarting level...");

        setTimeout(() => {
          // Reset player state
          gameState.player.lives = 3;
          gameState.player.brains = 0;
          gameState.brainsCollected = 0;
          gameState.collectedBrains = [];

          // ‚úÖ Safely reset visual counter only if it's visible
          const counterEl = document.getElementById("collectedCount");
          if (counterEl) counterEl.textContent = "0";

          gameState.quizUnlocked = false;
          gameState.brainsNeeded = (gameState.level === 3) ? 15 : 10;

          // Reset player position and velocity
          const player = gameState.player;
          player.x = 100;
          player.y = 300;
          player.velX = 0;
          player.velY = 0;
          player.grounded = false;

          // Reset collected brains
          gameState.brains.forEach(brain => brain.collected = false);

          hideRestartMessage();
          setupLevel(gameState.currentLevel);
        }, 2000);

      } else {
        respawnPlayer();
      }
    }

    function showRestartMessage(message) {
      let msg = document.getElementById('restartMessage');
      if (!msg) {
        msg = document.createElement('div');
        msg.id = 'restartMessage';
        msg.style.position = 'absolute';
        msg.style.top = '40%';
        msg.style.left = '50%';
        msg.style.transform = 'translate(-50%, -50%)';
        msg.style.background = '#fff';
        msg.style.border = '2px solid #000';
        msg.style.padding = '20px';
        msg.style.fontSize = '20px';
        msg.style.zIndex = 1000;
        msg.style.color = '#000';
        msg.style.maxWidth = '90%';
        msg.style.textAlign = 'center';
        document.body.appendChild(msg);
      }
      msg.textContent = message;
      msg.style.display = 'block';
    }

    function hideRestartMessage() {
      const msg = document.getElementById('restartMessage');
      if (msg) msg.style.display = 'none';
    }

    function respawnPlayer() {
      const player = gameState.player;
      player.x = 100;
      player.y = 300;
      player.velX = 0;
      player.velY = 0;
      player.grounded = false;
      gameState.isDead = false;
      deathOverlay.style.opacity = '0';
      setTimeout(() => {
        deathOverlay.style.display = 'none';
      }, 300);
    }

    // Draw everything
    function draw() {
      const cameraX = gameState.cameraX;
      
      // Clear canvas
      ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
      
        // Draw background - pass current level (assuming you track this in gameState)
  drawBackground(cameraX, gameState.currentLevel);
      
      // Draw platforms
      ctx.fillStyle = '#8B4513';
      for (const platform of gameState.platforms) {
        ctx.fillRect(platform.x - cameraX, platform.y, platform.width, platform.height);
        ctx.fillStyle = '#A0522D';
        ctx.fillRect(platform.x - cameraX, platform.y, platform.width, 5);
        ctx.fillStyle = '#8B4513';
      }
      
      // Draw brains
      for (const brain of gameState.brains) {
        if (!brain.collected) {
          ctx.fillStyle = '#FF66CC';
          ctx.beginPath();
          ctx.arc(brain.x - cameraX + 10, brain.y + 10, 10, 0, Math.PI * 2);
          ctx.fill();
          
          // Draw brain details
          ctx.fillStyle = '#FF99DD';
          ctx.beginPath();
          ctx.arc(brain.x - cameraX + 6, brain.y + 8, 3, 0, Math.PI * 2);
          ctx.arc(brain.x - cameraX + 14, brain.y + 8, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Draw enemies
      for (const enemy of gameState.enemies) {
        if (enemy.alive) {
          // Draw enemy based on type
          if (enemy.type === 'ground' || enemy.type === 'vertical') {
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(enemy.x - cameraX, enemy.y, enemy.width, enemy.height);
            
            // Draw enemy eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            const eyeOffset = (enemy.type === 'ground' && enemy.velX > 0) ? 8 : 2;
            ctx.arc(enemy.x - cameraX + eyeOffset, enemy.y + 10, 4, 0, Math.PI * 2);
            ctx.arc(enemy.x - cameraX + enemy.width - eyeOffset, enemy.y + 10, 4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(enemy.x - cameraX + eyeOffset, enemy.y + 10, 2, 0, Math.PI * 2);
            ctx.arc(enemy.x - cameraX + enemy.width - eyeOffset, enemy.y + 10, 2, 0, Math.PI * 2);
            ctx.fill();
          }
          else if (enemy.type === 'ranged') {
            // Draw ranged enemy (different color)
            ctx.fillStyle = '#FFA500';
            ctx.fillRect(enemy.x - cameraX, enemy.y, enemy.width, enemy.height);
            
            // Draw enemy eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(enemy.x - cameraX + 15, enemy.y + 10, 4, 0, Math.PI * 2);
            ctx.arc(enemy.x - cameraX + enemy.width - 15, enemy.y + 10, 4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(enemy.x - cameraX + 15, enemy.y + 10, 2, 0, Math.PI * 2);
            ctx.arc(enemy.x - cameraX + enemy.width - 15, enemy.y + 10, 2, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
      
      // Draw projectiles
 // Player projectiles (fixed version)
for (const p of gameState.playerProjectiles) {
  // Darker blue-teal gradient
  const gradient = ctx.createRadialGradient(
    p.x - cameraX, p.y, 0,
    p.x - cameraX, p.y, p.width/2
  );
  gradient.addColorStop(0, 'rgba(0, 150, 200, 0.9)');  // Darker center
  gradient.addColorStop(0.7, 'rgba(0, 100, 150, 0.8)'); // Mid tone
  gradient.addColorStop(1, 'rgba(0, 80, 120, 0.6)');   // Darker edge

  // Main bubble
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(p.x - cameraX, p.y, p.width/2, 0, Math.PI * 2);
  ctx.fill();
  
  // Thicker dark outline
  ctx.strokeStyle = 'rgba(0, 60, 90, 0.9)';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.arc(p.x - cameraX, p.y, p.width/2, 0, Math.PI * 2);
  ctx.stroke();
  
  // Smaller, subtle highlight (FIXED: changed 'y' to 'p.y')
  ctx.fillStyle = 'rgba(100, 200, 255, 0.4)';
  ctx.beginPath();
  ctx.arc(
    p.x - cameraX - p.width/6, 
    p.y - p.height/6,  // This was the problematic line - now fixed
    p.width/5,
    0, 
    Math.PI * 2
  );
  ctx.fill();
}

// Enemy projectiles (darker and more ominous)
for (const p of gameState.enemyProjectiles) {
  // Dark red gradient
  const gradient = ctx.createRadialGradient(
    p.x - cameraX, p.y, 0,
    p.x - cameraX, p.y, p.width/2
  );
  gradient.addColorStop(0, 'rgba(180, 0, 0, 0.9)');   // Blood red center
  gradient.addColorStop(0.7, 'rgba(120, 0, 0, 0.8)'); // Dark red mid
  gradient.addColorStop(1, 'rgba(80, 0, 0, 0.6)');    // Very dark edge

  // Main projectile
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(p.x - cameraX, p.y, p.width/2, 0, Math.PI * 2);
  ctx.fill();
  
  // Pulsing dark outline
  const pulseSize = Math.sin(Date.now()/100) * 1.5;
  ctx.strokeStyle = 'rgba(255, 100, 100, 0.8)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(
    p.x - cameraX, 
    p.y, 
    p.width/2 + pulseSize, 
    0, 
    Math.PI * 2
  );
  ctx.stroke();
  
  // Dark core for contrast
  ctx.fillStyle = 'rgba(50, 0, 0, 0.7)';
  ctx.beginPath();
  ctx.arc(p.x - cameraX, p.y, p.width/4, 0, Math.PI * 2);
  ctx.fill();
}
      
      // Draw end flag
      ctx.fillStyle = '#4CAF50';
      ctx.fillRect(gameState.endFlag.x - cameraX, gameState.endFlag.y, 5, gameState.endFlag.height);
      
      ctx.fillStyle = '#2196F3';
      ctx.beginPath();
      ctx.moveTo(gameState.endFlag.x - cameraX + 5, gameState.endFlag.y);
      ctx.lineTo(gameState.endFlag.x - cameraX + 25, gameState.endFlag.y + 15);
      ctx.lineTo(gameState.endFlag.x - cameraX + 5, gameState.endFlag.y + 30);
      ctx.closePath();
      ctx.fill();
      
      // Draw player (tadpole) with fixed direction
      const player = gameState.player;
      const drawX = player.x - cameraX;
      const drawY = player.y;
      
      ctx.fillStyle = '#4CAF50';
      ctx.beginPath();
      ctx.arc(
        drawX + player.width/2, 
        drawY + player.height/2, 
        player.width/2, 0, Math.PI * 2
      );
      ctx.fill();
      
      // Draw tail with wiggle
      ctx.beginPath();
      const now = performance.now();
      const isMoving = gameState.keys.left || gameState.keys.right;
      const tailDirection = -player.direction || 1;
      const wiggleY = isMoving ? Math.sin(now / 100) * 5 : 0;
      const baseX = drawX + player.width / 2 + tailDirection * player.width / 2;
      const baseY = drawY + player.height / 2 + wiggleY;
      
      ctx.moveTo(baseX, baseY);
      ctx.lineTo(baseX + tailDirection * player.width / 2, baseY);
      ctx.lineTo(baseX + tailDirection * player.width / 3, drawY + player.height + wiggleY);
      ctx.closePath();
      ctx.fill();
      
      // Draw eyes
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(
        drawX + player.width/3 + (player.direction > 0 ? player.width/3 : 0), 
        drawY + player.height/3, 
        4, 0, Math.PI * 2
      );
      ctx.fill();
      
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.arc(
        drawX + player.width/3 + (player.direction > 0 ? player.width/3 : 0), 
        drawY + player.height/3, 
        2, 0, Math.PI * 2
      );
      ctx.fill();
      
      // Draw collected brain counter
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(10, 10, 180, 40);
      
      ctx.fillStyle = 'white';
      ctx.font = '16px Arial';
      ctx.fillText(`Brains: ${gameState.collectedBrains.length}/${gameState.levels[gameState.currentLevel-1].brains}`, 20, 35);
      
      // Draw level indicator
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(gameCanvas.width - 190, 10, 180, 40);
      
      ctx.fillStyle = 'white';
      ctx.font = '16px Arial';
      ctx.fillText(`Level: ${gameState.currentLevel}`, gameCanvas.width - 180, 35);
      
      // Draw lives
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(gameCanvas.width/2 - 60, 10, 120, 40);
      
      ctx.fillStyle = 'white';
      ctx.font = '16px Arial';
      ctx.fillText(`Lives: ${gameState.player.lives}`, gameCanvas.width/2 - 50, 35);
    }

    function drawBackground(cameraX, level) {
  switch(level) {
    // Level 1: Underwater (introduction)
    case 1:
      drawBiolakeBackground(cameraX, true); 
      break;
      // Level 2: Forest (gentle rain)
    case 2:
      drawForestBackground(cameraX);
      break;
      
    // Level 3: Alien Planet (surreal)
    case 3:
      drawAlienBackground(cameraX);
      break;
      
    // Level 4: Volcanic Cavern (lava)
    case 4:
      drawVolcanoBackground(cameraX);
      break;
      
    // Level 5: Night City (contrast)
    case 5:
      drawCityBackground(cameraX);
      break;
      
    // Level 6: Sunny Default (calm before finale)
    case 6:
      drawForestBackground(cameraX);
      break;
      
    // Level 7: Deep Underwater (finale, darker)
    case 7:
      drawUnderwaterBackground(cameraX, false); // Darker version
      break;
      
    default: // Fallback
      drawUnderwaterBackground(cameraX); // Default underwater
 
    
    // Original background code (renamed from your existing drawBackground)
    // Sky gradient
   
    const skyGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
    skyGradient.addColorStop(0, '#87CEEB');
    skyGradient.addColorStop(1, '#E0F7FA');
    ctx.fillStyle = skyGradient;
    ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
    
    // Clouds
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    drawCloud(100 - cameraX/3, 50);
    drawCloud(300 - cameraX/3, 80);
    drawCloud(500 - cameraX/3, 60);
    drawCloud(700 - cameraX/3, 70);
    drawCloud(900 - cameraX/3, 65);
    drawCloud(1100 - cameraX/3, 55);
    
    // Sun rays
    const sunX = 700;
    const sunY = 80;
    const rayLength = 60;
    const rayCount = 12;
    
    ctx.strokeStyle = 'rgba(255, 235, 59, 0.6)';
    ctx.lineWidth = 2;
    for (let i = 0; i < rayCount; i++) {
      const angle = (Math.PI * 2 / rayCount) * i;
      const startX = sunX + Math.cos(angle) * 45;
      const startY = sunY + Math.sin(angle) * 45;
      const endX = sunX + Math.cos(angle) * (45 + rayLength);
      const endY = sunY + Math.sin(angle) * (45 + rayLength);
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
    }
    
    // Sun body
    ctx.fillStyle = '#FFEB3B';
    ctx.beginPath();
    ctx.arc(sunX, sunY, 40, 0, Math.PI * 2);
    ctx.fill();
    
    // Distant hills
    ctx.fillStyle = 'rgba(144, 238, 144, 0.6)';
    ctx.beginPath();
    ctx.moveTo(0 - cameraX/4, 350);
    for (let i = 0; i < 10; i++) {
      ctx.lineTo(i * 200 - cameraX/4, 300 - Math.sin(i) * 30);
    }
    ctx.lineTo(2000, 350);
    ctx.lineTo(0, 350);
    ctx.fill();
  }
}

    // Draw a cloud
    function drawCloud(x, y) {
      ctx.beginPath();
      ctx.arc(x, y, 20, 0, Math.PI * 2);
      ctx.arc(x + 15, y - 10, 15, 0, Math.PI * 2);
      ctx.arc(x + 30, y, 20, 0, Math.PI * 2);
      ctx.arc(x + 15, y + 10, 15, 0, Math.PI * 2);
      ctx.fill();
    }

// Underwater background
function drawUnderwaterBackground(cameraX) {
  // Water gradient (darker at depth, lighter near surface)
  const waterGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
  waterGradient.addColorStop(0, '#1a6a8a');  // Surface
  waterGradient.addColorStop(1, '#0a2e38');  // Depth
  ctx.fillStyle = waterGradient;
  ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
  
  // Light rays from surface
  ctx.strokeStyle = 'rgba(173, 216, 230, 0.3)';
  ctx.lineWidth = 2;
  for (let i = 0; i < 5; i++) {
    const x = 150 + i * 300 - cameraX * 0.2;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x + 50, gameCanvas.height);
    ctx.stroke();
  }
  
  // Bubbles (rising effect with camera)
  ctx.fillStyle = 'rgba(173, 216, 230, 0.6)';
  for (let i = 0; i < 15; i++) {
    const bubbleX = (i * 120 + (cameraX * 0.4)) % 1400;
    const bubbleY = (gameCanvas.height - (Date.now() * 0.05 + i * 40) % (gameCanvas.height + 50));
    const size = 3 + Math.sin(Date.now() * 0.001 + i) * 2;
    ctx.beginPath();
    ctx.arc(bubbleX, bubbleY, size, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Seaweed (foreground plants)
  ctx.fillStyle = '#2a7a3a';
  for (let i = 0; i < 8; i++) {
    drawSeaweed(200 + i * 180 - cameraX * 0.8, gameCanvas.height - 30);
  }
  
  // Coral reef (distant)
  ctx.fillStyle = 'rgba(205, 92, 92, 0.7)';
  ctx.beginPath();
  ctx.moveTo(0 - cameraX/5, gameCanvas.height - 50);
  for (let i = 0; i < 15; i++) {
    const x = i * 150 - cameraX/5;
    const height = 30 + Math.sin(i * 0.5) * 20;
    ctx.lineTo(x, gameCanvas.height - 50 - height);
  }
  ctx.lineTo(2000, gameCanvas.height - 50);
  ctx.fill();
}

// Draw seaweed plant
function drawSeaweed(x, y) {
  ctx.beginPath();
  // Main stem
  ctx.moveTo(x, y);
  ctx.bezierCurveTo(x + 10, y - 60, x - 10, y - 120, x, y - 180);
  
  // Leaves
  for (let i = 0; i < 5; i++) {
    const leafY = y - 30 - i * 30;
    ctx.moveTo(x, leafY);
    ctx.quadraticCurveTo(x + 15 + i * 3, leafY - 15, x, leafY - 30);
    ctx.moveTo(x, leafY);
    ctx.quadraticCurveTo(x - 15 - i * 3, leafY - 15, x, leafY - 30);
  }
  ctx.strokeStyle = '#2a7a3a';
  ctx.lineWidth = 3;
  ctx.stroke();
}

function drawBiolakeBackground(cameraX) {
  // Night water gradient (deep blue to dark teal)
  const waterGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
  waterGradient.addColorStop(0, '#0a2a3a');  // Surface (very dark blue)
  waterGradient.addColorStop(1, '#051a1a');  // Depth (dark teal)
  ctx.fillStyle = waterGradient;
  ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

  // Moon reflection (subtle light path)
  ctx.fillStyle = 'rgba(100, 150, 200, 0.1)';
  ctx.beginPath();
  ctx.moveTo(0, 0);
  for (let i = 0; i < 10; i++) {
    const x = i * 200 - cameraX * 0.1;
    const width = 100 + Math.sin(i) * 30;
    ctx.lineTo(x, 0);
    ctx.lineTo(x + width, gameCanvas.height);
  }
  ctx.lineTo(gameCanvas.width, gameCanvas.height);
  ctx.closePath();
  ctx.fill();

  // Glowing lily pads (platforms will go on top of these)
  for (let i = 0; i < 12; i++) {
    const x = (i * 250 + cameraX * 0.3) % (gameCanvas.width + 500);
    const y = gameCanvas.height - 50 + Math.sin(i * 0.5) * 10;
    
    // Outer glow
    const glowGradient = ctx.createRadialGradient(
      x, y, 30,
      x, y, 60
    );
    glowGradient.addColorStop(0, 'rgba(100, 200, 150, 0.4)');
    glowGradient.addColorStop(1, 'rgba(100, 200, 150, 0)');
    ctx.fillStyle = glowGradient;
    ctx.beginPath();
    ctx.arc(x, y, 60, 0, Math.PI * 2);
    ctx.fill();
    
    // Lily pad base
    ctx.fillStyle = '#1a3a2a';
    ctx.beginPath();
    ctx.ellipse(x, y, 50, 30, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Glowing veins
    ctx.strokeStyle = 'rgba(100, 255, 200, 0.6)';
    ctx.lineWidth = 1.5;
    for (let v = 0; v < 8; v++) {
      const angle = (Math.PI * 2 / 8) * v;
      const innerX = x + Math.cos(angle) * 10;
      const innerY = y + Math.sin(angle) * 10;
      const outerX = x + Math.cos(angle) * 40;
      const outerY = y + Math.sin(angle) * 25;
      ctx.beginPath();
      ctx.moveTo(innerX, innerY);
      ctx.lineTo(outerX, outerY);
      ctx.stroke();
    }
  }

  // Fireflies (animated glowing dots)
  ctx.fillStyle = 'rgba(200, 255, 150, 0.8)';
  for (let i = 0; i < 20; i++) {
    const baseX = (i * 150 + cameraX * 0.2) % (gameCanvas.width + 300);
    const timeOffset = i * 100;
    const x = baseX + Math.sin((Date.now() + timeOffset) * 0.001) * 50;
    const y = 100 + (i * 30) % (gameCanvas.height - 200) + 
              Math.sin((Date.now() + timeOffset) * 0.002) * 40;
    
    // Glow effect
    const glow = ctx.createRadialGradient(
      x, y, 0,
      x, y, 10
    );
    glow.addColorStop(0, 'rgba(200, 255, 150, 0.8)');
    glow.addColorStop(1, 'rgba(200, 255, 150, 0)');
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(x, y, 10, 0, Math.PI * 2);
    ctx.fill();
    
    // Core light
    ctx.fillStyle = 'rgba(255, 255, 200, 0.9)';
    ctx.beginPath();
    ctx.arc(x, y, 3, 0, Math.PI * 2);
    ctx.fill();
  }

  // Glowing reeds (background plants)
  for (let i = 0; i < 15; i++) {
    const x = (i * 180 - cameraX * 0.5) % (gameCanvas.width + 400);
    const height = 100 + Math.sin(i) * 40;
    drawGlowingReed(x, gameCanvas.height - 30, height);
  }

  
  // here's a very subtle version of the mushrooms:
  if (false) { // Change to 'true' if you want minimal mushrooms
    ctx.fillStyle = 'rgba(120, 80, 180, 0.15)'; // Much more subtle purple
    for (let i = 0; i < 5; i++) { // Fewer mushrooms
      const x = (i * 500 - cameraX * 0.1) % (gameCanvas.width + 800); // More spread out
      const y = gameCanvas.height - 70;
      const size = 15;
      
      // Just simple caps without glow effect
      ctx.beginPath();
      ctx.arc(x, y - size, size, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// Draw glowing reed plant
function drawGlowingReed(x, y, height) {
  // Main stem with glow
  const stemGradient = ctx.createLinearGradient(x, y, x, y - height);
  stemGradient.addColorStop(0, 'rgba(50, 150, 100, 0.8)');
  stemGradient.addColorStop(1, 'rgba(100, 200, 150, 0.4)');
  ctx.strokeStyle = stemGradient;
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x + 5, y - height);
  ctx.stroke();
  
  // Glowing nodes
  for (let i = 0; i < 3; i++) {
    const nodeY = y - (height / 4) * (i + 1);
    const nodeGlow = ctx.createRadialGradient(
      x + 3, nodeY, 0,
      x + 3, nodeY, 8
    );
    nodeGlow.addColorStop(0, 'rgba(100, 255, 200, 0.8)');
    nodeGlow.addColorStop(1, 'rgba(100, 255, 200, 0)');
    ctx.fillStyle = nodeGlow;
    ctx.beginPath();
    ctx.arc(x + 3, nodeY, 8, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Leaves with subtle glow
  for (let i = 0; i < 4; i++) {
    const leafY = y - (height / 5) * (i + 1);
    const leafLength = 30 + Math.sin(i) * 15;
    
    ctx.strokeStyle = 'rgba(100, 200, 150, 0.6)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x + 3, leafY);
    ctx.quadraticCurveTo(
      x + 20 + i * 5, 
      leafY - leafLength/2, 
      x + 10, 
      leafY - leafLength
    );
    ctx.stroke();
    
    // Leaf glow
    const leafGlow = ctx.createRadialGradient(
      x + 10, leafY - leafLength/2, 0,
      x + 10, leafY - leafLength/2, leafLength/2
    );
    leafGlow.addColorStop(0, 'rgba(100, 200, 150, 0.2)');
    leafGlow.addColorStop(1, 'rgba(100, 200, 150, 0)');
    ctx.fillStyle = leafGlow;
    ctx.beginPath();
    ctx.moveTo(x + 3, leafY);
    ctx.quadraticCurveTo(
      x + 20 + i * 5, 
      leafY - leafLength/2, 
      x + 10, 
      leafY - leafLength
    );
    ctx.lineTo(x + 3, leafY);
    ctx.fill();
  }
}

function drawCityBackground(cameraX) {
  // Night sky gradient
  const skyGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
  skyGradient.addColorStop(0, '#0a0a2a');
  skyGradient.addColorStop(1, '#1a1a40');
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

  // Stars
  ctx.fillStyle = 'white';
  for (let i = 0; i < 100; i++) {
    const x = (i * 50 + cameraX * 0.1) % (gameCanvas.width + 200);
    const y = (i * 30) % gameCanvas.height;
    const size = Math.random() * 1.5;
    ctx.fillRect(x, y, size, size);
  }

  // Distant buildings (parallax)
  ctx.fillStyle = '#222244';
  for (let i = 0; i < 15; i++) {
    const width = 80 + Math.sin(i) * 20;
    const height = 100 + Math.cos(i * 0.7) * 50;
    ctx.fillRect(
      i * 150 - cameraX * 0.3, 
      gameCanvas.height - height,
      width, 
      height
    );
  }

  // Closer buildings
  ctx.fillStyle = '#333366';
  for (let i = 0; i < 10; i++) {
    const height = 200 + Math.sin(i) * 40;
    ctx.fillRect(
      i * 200 - cameraX * 0.7, 
      gameCanvas.height - height,
      120, 
      height
    );
  }

  // Windows (yellow lights)
  ctx.fillStyle = 'rgba(255, 215, 0, 0.4)'; // More transparent gold
for (let i = 0; i < 20; i++) { // Fewer windows
  const x = (i * 150 + cameraX * 0.5) % 2000;
  const y = gameCanvas.height - 30 - (Math.floor(i / 4) * 50); // More spaced out
  if (Math.random() > 0.5) { // 50% chance to draw a window
    ctx.fillRect(x, y, 10, 15); // Smaller windows
  }
}
}

function drawVolcanoBackground(cameraX) {
  // Cave gradient (dark red to black)
  const caveGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
  caveGradient.addColorStop(0, '#3a0a0a');
  caveGradient.addColorStop(1, '#000000');
  ctx.fillStyle = caveGradient;
  ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

  // Lava river at bottom
  const lavaGradient = ctx.createLinearGradient(0, gameCanvas.height - 50, 0, gameCanvas.height);
  lavaGradient.addColorStop(0, '#ff4500');
  lavaGradient.addColorStop(1, '#ff8c00');
  ctx.fillStyle = lavaGradient;
  ctx.fillRect(0, gameCanvas.height - 30, gameCanvas.width, 30);

  // Lava bubbles
  ctx.fillStyle = '#ff6600';
  for (let i = 0; i < 8; i++) {
    const x = (i * 200 + cameraX * 0.4) % (gameCanvas.width + 300);
    const y = gameCanvas.height - 35 + Math.sin(Date.now() * 0.002 + i) * 3;
    ctx.beginPath();
    ctx.arc(x, y, 10 + Math.sin(Date.now() * 0.001 + i) * 5, 0, Math.PI * 2);
    ctx.fill();
  }

  // Stalactites
  ctx.fillStyle = '#555555';
  for (let i = 0; i < 20; i++) {
    const x = i * 150 - cameraX * 0.6;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x + 15, 0);
    ctx.lineTo(x + 7, 40 + Math.sin(i) * 20);
    ctx.closePath();
    ctx.fill();
  }
}

function drawAlienBackground(cameraX) {
  // Sky gradient (purple to pink)
  const skyGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
  skyGradient.addColorStop(0, '#4b0082');
  skyGradient.addColorStop(1, '#ff1493');
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

  // Floating alien orbs
  ctx.fillStyle = 'rgba(0, 255, 255, 0.4)';
  for (let i = 0; i < 6; i++) {
    const x = (i * 250 + cameraX * 0.2) % (gameCanvas.width + 400);
    const y = 100 + Math.sin(Date.now() * 0.001 + i) * 30;
    ctx.beginPath();
    ctx.arc(x, y, 30, 0, Math.PI * 2);
    ctx.fill();
  }

  // Strange plants
  ctx.fillStyle = '#7cfc00';
  for (let i = 0; i < 10; i++) {
    const x = i * 200 - cameraX * 0.5;
    ctx.beginPath();
    ctx.moveTo(x, gameCanvas.height);
    ctx.bezierCurveTo(
      x + 50, gameCanvas.height - 120,
      x - 50, gameCanvas.height - 180,
      x, gameCanvas.height - 220
    );
    ctx.lineWidth = 8;
    ctx.stroke();
  }

  // Twin moons
  ctx.fillStyle = 'rgba(255, 255, 0, 0.7)';
  ctx.beginPath();
  ctx.arc(150 - cameraX * 0.05, 80, 30, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = 'rgba(255, 100, 255, 0.5)';
  ctx.beginPath();
  ctx.arc(300 - cameraX * 0.03, 60, 40, 0, Math.PI * 2);
  ctx.fill();
}
function drawForestBackground(cameraX) {
  // Sky gradient (darker for contrast)
  const skyGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
  skyGradient.addColorStop(0, '#001f27');
  skyGradient.addColorStop(1, '#0d0020');
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

  // === GENTLE VERTICAL RAIN === //
  ctx.strokeStyle = 'rgba(180, 235, 255, 0.4)';
  ctx.lineWidth = 1.2;
  const rainDrops = 80; // Reduced quantity for subtlety
  
  for (let i = 0; i < rainDrops; i++) {
    const rainX = (i * 25 + cameraX * 0.1) % (gameCanvas.width + 50);
    const rainProgress = (Date.now() * 0.2 + i * 50) % (gameCanvas.height + 100);
    const rainY = rainProgress - 100; // Start above canvas
    
    // Only draw if visible
    if (rainY > -10 && rainY < gameCanvas.height) {
      const opacity = Math.min(1, rainProgress / 100) * 0.4; // Fade in at top
      const length = 12 + Math.sin(i) * 4; // Subtle variation
      
      ctx.save();
      ctx.globalAlpha = opacity;
      ctx.beginPath();
      ctx.moveTo(rainX, rainY);
      ctx.lineTo(rainX, rainY + length);
      ctx.stroke();
      ctx.restore();
    }
  }

  // === VARIED TREES === //
  const treeTypes = [
    // Type 1: Willow-style
    { color: '#00a896', draw: (x) => {
      ctx.fillStyle = '#5e503f';
      ctx.fillRect(x, gameCanvas.height - 100, 25, 100);
      ctx.fillStyle = '#00a896';
      for (let j = 0; j < 8; j++) {
        ctx.beginPath();
        ctx.moveTo(x + 12, gameCanvas.height - 100 + j * 5);
        ctx.quadraticCurveTo(
          x + 30 - j * 4, gameCanvas.height - 130 - j * 15,
          x + 50 - j * 8, gameCanvas.height - 80 - j * 5
        );
        ctx.lineTo(x - 26 + j * 8, gameCanvas.height - 80 - j * 5);
        ctx.quadraticCurveTo(
          x - 6 + j * 4, gameCanvas.height - 130 - j * 15,
          x + 12, gameCanvas.height - 100 + j * 5
        );
        ctx.fill();
      }
    }},
    
    // Type 2: Pine-style
    { color: '#02c39a', draw: (x) => {
      ctx.fillStyle = '#4a4e41';
      ctx.fillRect(x, gameCanvas.height - 120, 20, 120);
      for (let j = 0; j < 3; j++) {
        ctx.fillStyle = `rgba(2, 195, 154, ${0.7 - j * 0.2})`;
        ctx.beginPath();
        ctx.moveTo(x + 10, gameCanvas.height - 180 + j * 40);
        ctx.lineTo(x + 40 - j * 10, gameCanvas.height - 120 + j * 20);
        ctx.lineTo(x - 20 + j * 10, gameCanvas.height - 120 + j * 20);
        ctx.closePath();
        ctx.fill();
      }
    }},
    
    // Type 3: Glowing mushroom trees
    { color: '#ff6b6b', draw: (x) => {
      ctx.fillStyle = '#69385c';
      ctx.fillRect(x, gameCanvas.height - 80, 15, 80);
      ctx.fillStyle = '#ff6b6b';
      ctx.beginPath();
      ctx.arc(x + 7, gameCanvas.height - 100, 30, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      for (let j = 0; j < 5; j++) {
        ctx.beginPath();
        ctx.arc(
          x + 7 + Math.cos(j * 1.2) * 20,
          gameCanvas.height - 100 + Math.sin(j * 1.2) * 20,
          3 + Math.sin(Date.now() * 0.005 + j) * 2,
          0, Math.PI * 2
        );
        ctx.fill();
      }
    }}
  ];

  // Draw 8 trees with parallax
  for (let i = 0; i < 8; i++) {
    const treeType = treeTypes[i % treeTypes.length];
    const x = i * 300 - cameraX * 0.6;
    if (x > -200 && x < gameCanvas.width + 200) {
      treeType.draw(x);
    }
  }

  // === FOREGROUND FOLIAGE === //
  ctx.fillStyle = 'rgba(0, 168, 150, 0.3)';
  for (let i = 0; i < 40; i++) {
    const x = (i * 100 - cameraX * 0.9) % (gameCanvas.width + 400);
    const height = 30 + Math.sin(i) * 15;
    ctx.beginPath();
    ctx.moveTo(x, gameCanvas.height);
    ctx.lineTo(x + 20, gameCanvas.height - height);
    ctx.lineTo(x - 10, gameCanvas.height - height * 0.7);
    ctx.closePath();
    ctx.fill();
  }
}

    function endLevel() {
  gameState.gameActive = false;
  showScreen(quizScreen);

  // Reset quiz questions for this session
  gameState.quizQuestions = [];

  // Check game mode
  const isJuniorMode = document.getElementById('juniorMode').checked;
  
  // Get the appropriate question bank
  let bank;
  
  if (isJuniorMode) {
    // Junior Mode - use only the junior question bank
    bank = questionBanks.junior;
  } else {
    // Advanced Mode - use level-based difficulty progression
    if (gameState.currentLevel <= 2) bank = questionBanks.easy;
    else if (gameState.currentLevel <= 4) bank = questionBanks.medium;
    else bank = questionBanks.hard;
  }

  // Filter out questions already used in previous levels
  const availableQuestions = bank.filter(q => !gameState.usedQuestions.includes(q));

  // Determine how many questions to use (based on collected brains)
  const maxQuestions = 5;
  const numQuestions = Math.min(gameState.collectedBrains.length, maxQuestions);

  // Select random questions
  for (let i = 0; i < numQuestions; i++) {
    if (availableQuestions.length === 0) break;
    const randomIndex = Math.floor(Math.random() * availableQuestions.length);
    const selected = availableQuestions[randomIndex];
    gameState.quizQuestions.push(selected);
    gameState.usedQuestions.push(selected);
    availableQuestions.splice(randomIndex, 1);
  }

  gameState.score.total = gameState.quizQuestions.length;
  gameState.currentQuestion = 0;

  collectedCount.textContent = gameState.collectedBrains.length;
  showQuestion();
}

    // Show current question
    function showQuestion() {
      if (gameState.currentQuestion >= gameState.quizQuestions.length) {
        showScoreScreen();
        return;
      }
      
      const question = gameState.quizQuestions[gameState.currentQuestion];
      questionText.textContent = question.question;
      
      optionsContainer.innerHTML = '';
      question.options.forEach((option, index) => {
        const button = document.createElement('button');
        button.className = 'optionBtn';
        button.textContent = option;
        button.dataset.index = index;
        button.addEventListener('click', () => checkAnswer(index, question.answer, button));
        if (isMobile) {
          button.addEventListener('touchstart', () => checkAnswer(index, question.answer, button));
        }
        optionsContainer.appendChild(button);
      });
    }

    // Check if answer is correct
    function checkAnswer(selected, correct, button) {
      // Disable all buttons
      const buttons = optionsContainer.querySelectorAll('.optionBtn');
      buttons.forEach(btn => {
        btn.disabled = true;
        btn.style.cursor = 'default';
      });
      
      // Mark correct and incorrect
      if (selected === correct) {
        button.classList.add('correct');
        gameState.score.correct++;
      } else {
        button.classList.add('incorrect');
        // Also highlight correct answer
        buttons[correct].classList.add('correct');
      }
      
      // Move to next question after delay
      setTimeout(() => {
        gameState.currentQuestion++;
        showQuestion();
      }, 1500);
    }

    function showScoreScreen() {
      showScreen(scoreScreen);

      const correct = gameState.score.correct;
      const total = gameState.score.total;
      const percentage = Math.round((correct / total) * 100);

      scoreSummary.textContent = `You scored ${correct}/${total} (${percentage}%) on the ${gameState.levels[gameState.currentLevel - 1].name} quiz!`;

      if (gameState.currentLevel === 7) {
        // Immediately hide score screen and show final screen
        setTimeout(() => {
          showScreen(finalScreen);
          finalText.textContent =
            `You've completed all 7 levels!\n` +
            `Final Score: ${correct}/${total} (${percentage}%)\n\n` +
            `Thanks for playing Tadpole Trials!\nGood luck with your Biology studies! Mr. Gillespie`;
        }, 1500);
      } else {
        nextBtn.style.display = 'inline-block';
      }
    }

    // Retry current level
    function retryLevel() {
      showScreen(gameCanvas);
      setupLevel(gameState.currentLevel);
      gameState.gameActive = true;
      requestAnimationFrame(gameLoop);
    }

    // Go to next level
    function nextLevel() {
      if (gameState.currentLevel < 7) {
        setupLevel(gameState.currentLevel + 1);
        showScreen(gameCanvas);
        gameState.gameActive = true;
        requestAnimationFrame(gameLoop);
      } else {
        showFinalScreen();
      }
    }

    // Show final screen
    function showFinalScreen() {
      showScreen(finalScreen);
    }

    // Restart game
    function restartGame() {
      showScreen(startScreen);
    }

    // Reset game state
    function resetGameState() {
      gameState.currentLevel = 1;
      gameState.levels.forEach(level => {
        level.collected = 0;
      });
    }

    // Handle key down
    function handleKeyDown(e) {
      if (!gameState.gameActive) return;
      
      if (e.key === 'ArrowLeft' || e.key === 'a') {
        gameState.keys.left = true;
      } else if (e.key === 'ArrowRight' || e.key === 'd') {
        gameState.keys.right = true;
      } else if ((e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') && gameState.player.grounded) {
        gameState.keys.up = true;
      } else if (e.key === 'r' || e.key === 'R') {
        gameState.keys.r = true;
      } else if (e.key === 'f' || e.key === 'F') {
        gameState.keys.shoot = true;
      }
    }

    // Handle key up
    function handleKeyUp(e) {
      if (e.key === 'ArrowLeft' || e.key === 'a') {
        gameState.keys.left = false;
      } else if (e.key === 'ArrowRight' || e.key === 'd') {
        gameState.keys.right = false;
      } else if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') {
        gameState.keys.up = false;
      } else if (e.key === 'r' || e.key === 'R') {
        gameState.keys.r = false;
      } else if (e.key === 'f' || e.key === 'F') {
        gameState.keys.shoot = false;
      }
    }

   const questionBanks = {
  junior: [
    // Area of Study 1: How do cells function?
    {
      question: "Who was the first scientist to observe cells under a microscope?",
      options: ["Robert Hooke", "Charles Darwin", "Gregor Mendel", "Louis Pasteur"],
      answer: 0
    },
    {
      question: "Which organelle is known as the 'powerhouse' of the cell?",
      options: ["Ribosome", "Nucleus", "Mitochondria", "Chloroplast"],
      answer: 2
    },
    {
      question: "What is the main function of the cell membrane?",
      options: ["Produce energy", "Make proteins", "Store genetic information", "Control what enters/exits the cell"],
      answer: 3
    },
    {
      question: "Why do cells need a large surface area to volume ratio?",
      options: ["To store more water", "For efficient material exchange", "To look bigger", "To move faster"],
      answer: 1
    },
    {
      question: "What process do cells use to divide and grow?",
      options: ["Osmosis", "Cell cycle", "Photosynthesis", "Respiration"],
      answer: 1
    },
    {
      question: "What is the purpose of programmed cell death (apoptosis)?",
      options: ["To create energy", "To help cells move", "To remove damaged cells", "To make organisms grow bigger"],
      answer: 2
    },
    {
      question: "What happens when cells differentiate?",
      options: ["They divide rapidly", "They become specialized", "They get smaller", "They die"],
      answer: 1
    },

    // Area of Study 2: Plant and animal systems
    {
      question: "Which of these is the correct organization sequence in multicellular organisms?",
      options: ["Tissues ‚Üí Cells ‚Üí Organs ‚Üí Organ Systems", 
               "Cells ‚Üí Tissues ‚Üí Organs ‚Üí Organ Systems", 
               "Organs ‚Üí Tissues ‚Üí Cells ‚Üí Organ Systems",
               "Cells ‚Üí Organs ‚Üí Tissues ‚Üí Organ Systems"],
      answer: 1
    },
    {
      question: "What is the function of xylem in plants?",
      options: ["Produce seeds", "Transport water", "Capture sunlight", "Transport sugars"],
      answer: 1
    },
    {
      question: "Which system transports oxygen in animals?",
      options: ["Nervous system", "Digestive system", "Circulatory system", "Skeletal system"],
      answer: 2
    },
    {
      question: "What is homeostasis?",
      options: ["Energy production", "Waste removal", "Cell division", "Maintaining stable internal conditions"],
      answer: 3
    },
    {
      question: "What plant hormone causes stems to bend toward light?",
      options: ["Testosterone", "Auxin", "Adrenaline", "Insulin"],
      answer: 1
    },
    {
      question: "Which gland controls metabolism in animals?",
      options: ["Liver", "Pancreas", "Thyroid", "Kidney"],
      answer: 2
    },
    {
      question: "What condition results from the pancreas not producing enough insulin?",
      options: ["Asthma", "Arthritis", "Anemia", "Diabetes"],
      answer: 3
    },

    // Unit 2: Inheritance and diversity
    {
      question: "What is a genome?",
      options: ["A kind of protein", "A cell organelle", "All the genetic material in an organism", "A type of cell"],
      answer: 2
    },
    {
      question: "Humans normally have how many chromosomes?",
      options: ["64", "23", "46", "12"],
      answer: 2
    },
    {
      question: "What process creates gametes (sperm/egg cells)?",
      options: ["Photosynthesis", "Mitosis", "Meiosis", "Respiration"],
      answer: 2
    },
    {
      question: "What are different versions of the same gene called?",
      options: ["Traits", "Chromosomes", "Alleles", "Proteins"],
      answer: 2
    },
    {
      question: "What does epigenetics study?",
      options: ["Animal behavior", "Plant growth", "Cell division", "Gene expression changes not involving DNA sequence"],
      answer: 3
    },
    {
      question: "In a monohybrid cross (Aa √ó Aa), what percentage of offspring show the dominant trait?",
      options: ["100%", "25%", "50%", "75%"],
      answer: 3
    },
    {
      question: "What does a shaded shape in a pedigree chart usually represent?",
      options: ["Female", "Deceased individual", "Affected individual", "Male"],
      answer: 2
    },
    {
      question: "Which is an example of asexual reproduction?",
      options: ["Flower pollination", "Human reproduction", "Bacteria dividing", "Bird eggs"],
      answer: 2
    },
    {
      question: "What advantage does sexual reproduction provide?",
      options: ["No mate needed", "Less energy required", "Faster reproduction", "Genetic diversity"],
      answer: 3
    },
    {
      question: "What is a clone?",
      options: ["A type of chromosome", "A cell organelle", "A kind of protein", "A genetically identical organism"],
      answer: 3
    },
    {
      question: "What helps organisms survive in their environment?",
      options: ["Large size", "Bright colors", "Fast movement", "Adaptations"],
      answer: 3
    },
    {
      question: "What is a community of living organisms called?",
      options: ["Habitat", "Population", "Biome", "Ecosystem"],
      answer: 3
    },

    // Additional questions
    {
      question: "Which microscope has higher magnification - light or electron?",
      options: ["Both are equal", "Neither has magnification", "Light microscope", "Electron microscope"],
      answer: 3
    },
    {
      question: "What process do plants use to make food?",
      options: ["Transpiration", "Digestion", "Respiration", "Photosynthesis"],
      answer: 3
    },
    {
      question: "Which blood vessels carry blood away from the heart?",
      options: ["All of these", "Capillaries", "Veins", "Arteries"],
      answer: 3
    },
    {
      question: "What is the function of white blood cells?",
      options: ["Digest food", "Carry oxygen", "Clot blood", "Fight infection"],
      answer: 3
    },
    {
      question: "Which is NOT a function of the skeleton?",
      options: ["Support", "Photosynthesis", "Movement", "Protection"],
      answer: 1
    },
    {
  question: "What do ribosomes do in a cell?",
  options: ["Make energy", "Make proteins", "Store water", "Control the cell"],
  answer: 1
},
{
  question: "Where is DNA found in a eukaryotic cell?",
  options: ["Cell membrane", "Mitochondria", "Nucleus", "Cytoplasm"],
  answer: 2
},
{
  question: "What type of cells have no nucleus?",
  options: ["Muscle cells", "Plant cells", "Bacterial cells", "Fungal cells"],
  answer: 2
},
{
  question: "Which part of the plant carries out most photosynthesis?",
  options: ["Roots", "Flowers", "Stems", "Leaves"],
  answer: 3
},
{
  question: "Which organ in humans filters waste from the blood?",
  options: ["Liver", "Kidney", "Heart", "Lungs"],
  answer: 1
},
{
  question: "What do chloroplasts contain that makes plants green?",
  options: ["Enzymes", "Glucose", "Chlorophyll", "Carbon dioxide"],
  answer: 2
},
{
  question: "What is the name for all the chemical reactions in an organism?",
  options: ["Digestion", "Photosynthesis", "Respiration", "Metabolism"],
  answer: 3
},
{
  question: "Which gas do humans breathe in to stay alive?",
  options: ["Oxygen", "Nitrogen", "Carbon dioxide", "Hydrogen"],
  answer: 0
},
{
  question: "What is the basic unit of life?",
  options: ["Tissue", "Organ", "Organ system", "Cell"],
  answer: 3
},
{
  question: "What is the role of the large intestine?",
  options: ["Absorb nutrients", "Filter blood", "Absorb water", "Break down fats"],
  answer: 2
},
{
  question: "Which sense organ responds to sound?",
  options: ["Eyes", "Tongue", "Ears", "Nose"],
  answer: 2
},
{
  question: "Which structure in animals helps move electrical signals?",
  options: ["Muscle tissue", "Bone", "Nerves", "Lungs"],
  answer: 2
},
{
  question: "Which feature do all mammals share?",
  options: ["Lay eggs", "Have feathers", "Produce milk", "Have gills"],
  answer: 2
},
{
  question: "What do enzymes do in the body?",
  options: ["Break down food", "Transport oxygen", "Attack viruses", "Absorb water"],
  answer: 0
},
{
  question: "Which part of a plant anchors it in the ground?",
  options: ["Stem", "Leaves", "Roots", "Flower"],
  answer: 2
}

  ],
    
      easy: [
        {
          question: "What is the basic unit of life?",
          options: ["Atom", "Cell", "Tissue", "Organelle"],
          answer: 1
        },
        {
          question: "Which molecule carries genetic information?",
          options: ["Protein", "DNA", "Lipid", "ATP"],
          answer: 1
        },
        {
          question: "What is the role of mRNA?",
          options: ["Cuts DNA", "Synthesises proteins", "Carries genetic code from DNA to ribosome", "Produces glucose"],
          answer: 2
        },
        {
          question: "Which organelle is the site of protein synthesis?",
          options: ["Golgi apparatus", "Nucleus", "Ribosome", "Lysosome"],
          answer: 2
        },
        {
          question: "Which stage of cellular respiration produces 2 ATP?",
          options: ["Glycolysis", "Electron Transport Chain", "Light-dependent stage", "Photosystem II"],
          answer: 0
        },
        {
          question: "What gas do plants take in for photosynthesis?",
          options: ["Oxygen", "Carbon dioxide", "Hydrogen", "Methane"],
          answer: 1
        },
        {
          question: "Which type of immunity results from a vaccine?",
          options: ["Natural passive", "Natural active", "Artificial passive", "Artificial active"],
          answer: 3
        },
        {
          question: "Which barrier prevents pathogen entry in plants?",
          options: ["Skin", "Waxy cuticle", "White blood cells", "Platelets"],
          answer: 1
        },
        {
          question: "What is an intron?",
          options: ["A protein", "A coding region of DNA", "A non-coding region of a gene", "A ribosome"],
          answer: 2
        },
        {
          question: "Which stage in photosynthesis produces glucose?",
          options: ["Light-dependent", "Light-independent", "Krebs cycle", "Electron transport chain"],
          answer: 1
        }
      ],
      medium: [
        {
          question: "Which RNA molecule brings amino acids to the ribosome?",
          options: ["mRNA", "rRNA", "tRNA", "siRNA"],
          answer: 2
        },
        {
          question: "What is a bioethical concern of GM crops?",
          options: ["Low yields", "Misuse of fertilizers", "Unintended environmental impacts", "Inability to photosynthesise"],
          answer: 2
        },
        {
          question: "Which part of a gene is involved in regulation?",
          options: ["Exon", "Promoter", "Intron", "tRNA"],
          answer: 1
        },
        {
          question: "Which statement describes the universal nature of the genetic code?",
          options: ["All organisms use different codons", "Codons are randomly assigned", "All organisms share the same codon meanings", "Codons change across species"],
          answer: 2
        },
        {
          question: "What role do coenzymes like NADH play in respiration?",
          options: ["Provide energy", "Carry hydrogen/electrons", "Break down glucose", "Form cell membranes"],
          answer: 1
        },
        {
          question: "What is a key difference between CRISPR-Cas9 and restriction enzymes?",
          options: ["Only CRISPR-Cas9 can cut DNA", "Restriction enzymes are programmable", "CRISPR-Cas9 can be directed to any DNA sequence using RNA", "Restriction enzymes are found in eukaryotes"],
          answer: 2
        },
        {
          question: "Which factor would most decrease enzyme activity?",
          options: ["Slight temperature increase", "Optimal pH", "Low substrate concentration", "Presence of a non-competitive inhibitor"],
          answer: 3
        },
        {
          question: "What defines herd immunity?",
          options: ["Only unvaccinated individuals are protected", "Enough individuals are immune to prevent spread", "The disease has been eradicated", "All people must be vaccinated"],
          answer: 1
        },
        {
          question: "What does a phylogenetic tree show?",
          options: ["Protein function", "Organ growth", "Genetic relatedness", "Food webs"],
          answer: 2
        },
        {
          question: "Why might mtDNA be used in evolutionary studies?",
          options: ["It mutates slowly", "It's inherited maternally and mutates rapidly", "It can't be extracted", "It encodes traits like height"],
          answer: 1
        }
      ],
      hard: [
        {
          question: "In the CRISPR-Cas9 system, where must the PAM be located relative to the DNA sequence targeted by the single-guide RNA?",
          options: [
            "Upstream (5‚Ä≤ side) on the target strand",
            "Downstream (3‚Ä≤ side) on the non-target strand",
            "Anywhere within 20 bp on either strand",
            "Within the guide RNA itself"
          ],
          answer: 1
        },
        {
          question: "A bacterium has high tryptophan levels but its trp repressor cannot bind the operator. Which mechanism will still reduce transcription of the structural genes?",
          options: [
            "Inducer exclusion",
            "Catabolite repression",
            "Attenuation via formation of a terminator hairpin",
            "Antisense RNA"
          ],
          answer: 2
        },
        {
          question: "Why does the trp operon show a low basal (leaky) transcription rate even when the active repressor is bound?",
          options: [
            "RNA polymerase can never bind",
            "The repressor periodically dissociates, allowing short bursts of initiation",
            "Attenuation fails at high tryptophan",
            "Tryptophan is rapidly degraded"
          ],
          answer: 1
        },
        {
          question: "How do monoclonal antibodies function when used as an antivenom for snake bites?",
options: [
  "They activate memory B cells to produce specific antibodies.",
  "They neutralise venom toxins by binding to them directly.",
  "They stimulate cytotoxic T cells to destroy venom-infected cells.",
  "They trigger inflammation to remove venom from tissues."
],
answer: 1
        },
        {
          question: "Why does the total ATP yield from aerobic respiration range between 26 and 28 molecules per glucose?",
options: [
  "FADH‚ÇÇ produces more ATP than NADH in the electron transport chain",
  "Cytosolic NADH transfers electrons via different shuttles, affecting whether they reduce FAD or NAD‚Å∫",
  "The number of CO‚ÇÇ molecules produced varies",
  "Oxygen availability changes the number of protons pumped"
],
answer: 1
        },
        {
          question: "Which correctly contrasts C‚ÇÑ and CAM plants in limiting photorespiration?",
          options: [
            "C‚ÇÑ separates Calvin cycle by time; CAM by space",
            "C‚ÇÑ fixes CO‚ÇÇ at night; CAM in bundle-sheath cells",
            "C‚ÇÑ uses PEP-carboxylase in mesophyll cells; CAM stores fixed CO‚ÇÇ as malate at night for daytime Calvin cycle",
            "Both run Calvin cycle at night"
          ],
          answer: 2
        },
        {
          question: "During alcoholic fermentation, decarboxylation of pyruvate directly produces:",
          options: [
            "Acetyl-CoA",
            "Ethanol",
            "CO‚ÇÇ and acetaldehyde",
            "Lactate"
          ],
          answer: 2
        },
        {
          question: "During PCR, why does the DNA polymerase remain active at high temperatures?",
          options: [
            "It is re-added after each cycle",
            "It is sourced from a thermophilic organism such as Thermus aquaticus",
            "The buffer neutralises heat",
            "DNA primers stabilise the enzyme"
          ],
          answer: 1
        },
        {
          question: "Which of the following is true about MHC class I and MHC class II molecules?",
          options: [
            "MHC I presents extracellular antigens to B cells",
            "MHC II is found on all nucleated cells",
            "MHC I presents intracellular peptides to cytotoxic T cells",
            "MHC II activates cytotoxic T cells"
          ],
          answer: 2
        },
        {
          question: "A viral peptide presented on MHC II of a dendritic cell will be recognised by which lymphocyte, and what is the immediate outcome?",
          options: [
            "Cytotoxic T ‚Üí apoptosis",
            "Helper T ‚Üí activation & cytokine release",
            "B cell ‚Üí antibody secretion",
            "NK cell ‚Üí perforin release"
          ],
          answer: 1
        },
        {
          question: "Why do scientists use insulin cDNA instead of the full human insulin gene when inserting it into E. coli for protein production?",
options: [
  "cDNA contains bacterial promoters needed for transcription",
  "The full human gene contains introns that E. coli cannot process",
  "cDNA is circular like a plasmid",
  "The human gene lacks a ribosome-binding site"
],
answer: 1
        },
        {
          question: "Why is the proteome considered more complex than the genome in a multicellular organism?",
options: [
  "The proteome includes all non-coding DNA elements",
  "A single gene can give rise to multiple proteins via alternative splicing and post-translational modifications",
  "Proteins can directly encode new DNA sequences",
  "The genome changes in different cell types while the proteome stays constant"
],
answer: 1
        },
        {
          question: "What does a small difference in DNA sequences between two species suggest about their evolutionary relationship?",
          options: [
            "They do not share a common ancestor",
            "They likely evolved under different environmental pressures",
            "They diverged from a common ancestor relatively recently",
            "One evolved directly from the other"
          ],
          answer: 2
        },
        {
          question: "Which best describes the difference between absolute and relative dating?",
          options: [
            "Absolute dating is faster",
            "Relative dating uses isotopes; absolute dating uses layers",
            "Absolute dating estimates actual age in years; relative dating compares order of events",
            "Relative dating only works for rocks younger than 10,000 years"
          ],
          answer: 2
        },
        {
          question: "What does a transitional fossil most directly demonstrate?",
          options: [
            "Extinction of older species",
            "Sudden appearance of new traits",
            "Intermediate traits between ancestral and derived species",
            "Variation within a single population"
          ],
          answer: 2
        }
      ]
    };

    // Initialize the game when page loads
    window.addEventListener('load', init);
  </script>
</body>
</html>